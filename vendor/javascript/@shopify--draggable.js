var e={};(function webpackUniversalModuleDefinition(t,r){e=r()})(window,(function(){return function(e){var t={};function __webpack_require__(r){if(t[r])return t[r].exports;var n=t[r]={i:r,l:false,exports:{}};e[r].call(n.exports,n,n.exports,__webpack_require__);n.l=true;return n.exports}__webpack_require__.m=e;__webpack_require__.c=t;__webpack_require__.d=function(e,t,r){__webpack_require__.o(e,t)||Object.defineProperty(e,t,{enumerable:true,get:r})};__webpack_require__.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"});Object.defineProperty(e,"__esModule",{value:true})};__webpack_require__.t=function(e,t){1&t&&(e=__webpack_require__(e));if(8&t)return e;if(4&t&&"object"===typeof e&&e&&e.__esModule)return e;var r=Object.create(null);__webpack_require__.r(r);Object.defineProperty(r,"default",{enumerable:true,value:e});if(2&t&&"string"!=typeof e)for(var n in e)__webpack_require__.d(r,n,function(t){return e[t]}.bind(null,n));return r};__webpack_require__.n=function(e){var t=e&&e.__esModule?function getDefault(){return e["default"]}:function getModuleExports(){return e};__webpack_require__.d(t,"a",t);return t};__webpack_require__.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)};__webpack_require__.p="";return __webpack_require__(__webpack_require__.s=72)}([function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=r(66);var o=_interopRequireDefault(n);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}t.default=o.default},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=r(70);var o=_interopRequireDefault(n);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}t.default=o.default},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=r(57);Object.defineProperty(t,"closest",{enumerable:true,get:function(){return _interopRequireDefault(n).default}});var o=r(55);Object.defineProperty(t,"requestNextAnimationFrame",{enumerable:true,get:function(){return _interopRequireDefault(o).default}});var i=r(53);Object.defineProperty(t,"distance",{enumerable:true,get:function(){return _interopRequireDefault(i).default}});var s=r(51);Object.defineProperty(t,"touchCoords",{enumerable:true,get:function(){return _interopRequireDefault(s).default}});function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=r(46);Object.keys(n).forEach((function(e){"default"!==e&&"__esModule"!==e&&Object.defineProperty(t,e,{enumerable:true,get:function(){return n[e]}})}))},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=r(49);var o=_interopRequireDefault(n);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}t.default=o.default},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=r(14);Object.keys(n).forEach((function(e){"default"!==e&&"__esModule"!==e&&Object.defineProperty(t,e,{enumerable:true,get:function(){return n[e]}})}));var o=r(13);Object.keys(o).forEach((function(e){"default"!==e&&"__esModule"!==e&&Object.defineProperty(t,e,{enumerable:true,get:function(){return o[e]}})}));var i=r(12);Object.keys(i).forEach((function(e){"default"!==e&&"__esModule"!==e&&Object.defineProperty(t,e,{enumerable:true,get:function(){return i[e]}})}));var s=r(6);Object.keys(s).forEach((function(e){"default"!==e&&"__esModule"!==e&&Object.defineProperty(t,e,{enumerable:true,get:function(){return s[e]}})}));var a=r(39);var l=_interopRequireDefault(a);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}t.default=l.default},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=r(4);Object.defineProperty(t,"Sensor",{enumerable:true,get:function(){return _interopRequireDefault(n).default}});var o=r(48);Object.defineProperty(t,"MouseSensor",{enumerable:true,get:function(){return _interopRequireDefault(o).default}});var i=r(45);Object.defineProperty(t,"TouchSensor",{enumerable:true,get:function(){return _interopRequireDefault(i).default}});var s=r(43);Object.defineProperty(t,"DragSensor",{enumerable:true,get:function(){return _interopRequireDefault(s).default}});var a=r(41);Object.defineProperty(t,"ForceTouchSensor",{enumerable:true,get:function(){return _interopRequireDefault(a).default}});var l=r(3);Object.keys(l).forEach((function(e){"default"!==e&&"__esModule"!==e&&Object.defineProperty(t,e,{enumerable:true,get:function(){return l[e]}})}));function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=r(20);Object.keys(n).forEach((function(e){"default"!==e&&"__esModule"!==e&&Object.defineProperty(t,e,{enumerable:true,get:function(){return n[e]}})}))},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=r(25);Object.keys(n).forEach((function(e){"default"!==e&&"__esModule"!==e&&Object.defineProperty(t,e,{enumerable:true,get:function(){return n[e]}})}))},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=r(29);Object.keys(n).forEach((function(e){"default"!==e&&"__esModule"!==e&&Object.defineProperty(t,e,{enumerable:true,get:function(){return n[e]}})}))},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=r(32);Object.keys(n).forEach((function(e){"default"!==e&&"__esModule"!==e&&Object.defineProperty(t,e,{enumerable:true,get:function(){return n[e]}})}))},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=r(35);Object.keys(n).forEach((function(e){"default"!==e&&"__esModule"!==e&&Object.defineProperty(t,e,{enumerable:true,get:function(){return n[e]}})}))},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=r(68);Object.defineProperty(t,"Announcement",{enumerable:true,get:function(){return _interopRequireDefault(n).default}});Object.defineProperty(t,"defaultAnnouncementOptions",{enumerable:true,get:function(){return n.defaultOptions}});var o=r(65);Object.defineProperty(t,"Focusable",{enumerable:true,get:function(){return _interopRequireDefault(o).default}});var i=r(63);Object.defineProperty(t,"Mirror",{enumerable:true,get:function(){return _interopRequireDefault(i).default}});Object.defineProperty(t,"defaultMirrorOptions",{enumerable:true,get:function(){return i.defaultOptions}});var s=r(59);Object.defineProperty(t,"Scrollable",{enumerable:true,get:function(){return _interopRequireDefault(s).default}});Object.defineProperty(t,"defaultScrollableOptions",{enumerable:true,get:function(){return s.defaultOptions}});function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=r(69);Object.keys(n).forEach((function(e){"default"!==e&&"__esModule"!==e&&Object.defineProperty(t,e,{enumerable:true,get:function(){return n[e]}})}))},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=r(71);Object.keys(n).forEach((function(e){"default"!==e&&"__esModule"!==e&&Object.defineProperty(t,e,{enumerable:true,get:function(){return n[e]}})}))},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});t.defaultOptions=void 0;var n=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e};var o=r(0);var i=_interopRequireDefault(o);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const s=Symbol("onSortableSorted");const a=Symbol("onSortableSort");
/**
       * SortAnimation default options
       * @property {Object} defaultOptions
       * @property {Number} defaultOptions.duration
       * @property {String} defaultOptions.easingFunction
       * @type {Object}
       */const l=t.defaultOptions={duration:150,easingFunction:"ease-in-out"};class SortAnimation extends i.default{
/**
         * SortAnimation constructor.
         * @constructs SortAnimation
         * @param {Draggable} draggable - Draggable instance
         */
constructor(e){super(e);
/**
           * SortAnimation options
           * @property {Object} options
           * @property {Number} defaultOptions.duration
           * @property {String} defaultOptions.easingFunction
           * @type {Object}
           */this.options=n({},l,this.getOptions());
/**
           * Last animation frame
           * @property {Number} lastAnimationFrame
           * @type {Number}
           */this.lastAnimationFrame=null;this.lastElements=[];this[s]=this[s].bind(this);this[a]=this[a].bind(this)}attach(){this.draggable.on("sortable:sort",this[a]);this.draggable.on("sortable:sorted",this[s])}detach(){this.draggable.off("sortable:sort",this[a]);this.draggable.off("sortable:sorted",this[s])}getOptions(){return this.draggable.options.sortAnimation||{}}
/**
         * Sortable sort handler
         * @param {SortableSortEvent} sortableEvent
         * @private
         */[a]({dragEvent:e}){const{sourceContainer:t}=e;const r=this.draggable.getDraggableElementsForContainer(t);this.lastElements=Array.from(r).map((e=>({domEl:e,offsetTop:e.offsetTop,offsetLeft:e.offsetLeft})))}
/**
         * Sortable sorted handler
         * @param {SortableSortedEvent} sortableEvent
         * @private
         */[s]({oldIndex:e,newIndex:t}){if(e===t)return;const r=[];let n;let o;let i;if(e>t){n=t;o=e-1;i=1}else{n=e+1;o=t;i=-1}for(let e=n;e<=o;e++){const t=this.lastElements[e];const n=this.lastElements[e+i];r.push({from:t,to:n})}cancelAnimationFrame(this.lastAnimationFrame);this.lastAnimationFrame=requestAnimationFrame((()=>{r.forEach((e=>animate(e,this.options)))}))}}t.default=SortAnimation;
/**
       * Animates two elements
       * @param {Object} element
       * @param {Object} element.from
       * @param {Object} element.to
       * @param {Object} options
       * @param {Number} options.duration
       * @param {String} options.easingFunction
       * @private
       */function animate({from:e,to:t},{duration:r,easingFunction:n}){const o=e.domEl;const i=e.offsetLeft-t.offsetLeft;const s=e.offsetTop-t.offsetTop;o.style.pointerEvents="none";o.style.transform=`translate3d(${i}px, ${s}px, 0)`;requestAnimationFrame((()=>{o.addEventListener("transitionend",resetElementOnTransitionEnd);o.style.transition=`transform ${r}ms ${n}`;o.style.transform=""}))}
/**
       * Resets animation style properties after animation has completed
       * @param {Event} event
       * @private
       */function resetElementOnTransitionEnd(e){e.target.style.transition="";e.target.style.pointerEvents="";e.target.removeEventListener("transitionend",resetElementOnTransitionEnd)}},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});t.defaultOptions=void 0;var n=r(15);var o=_interopRequireDefault(n);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}t.default=o.default;t.defaultOptions=n.defaultOptions},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});t.defaultOptions=void 0;var n=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e};var o=r(0);var i=_interopRequireDefault(o);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const s=Symbol("onSortableSorted");
/**
       * SwapAnimation default options
       * @property {Object} defaultOptions
       * @property {Number} defaultOptions.duration
       * @property {String} defaultOptions.easingFunction
       * @property {Boolean} defaultOptions.horizontal
       * @type {Object}
       */const a=t.defaultOptions={duration:150,easingFunction:"ease-in-out",horizontal:false};class SwapAnimation extends i.default{
/**
         * SwapAnimation constructor.
         * @constructs SwapAnimation
         * @param {Draggable} draggable - Draggable instance
         */
constructor(e){super(e);
/**
           * SwapAnimation options
           * @property {Object} options
           * @property {Number} defaultOptions.duration
           * @property {String} defaultOptions.easingFunction
           * @type {Object}
           */this.options=n({},a,this.getOptions());
/**
           * Last animation frame
           * @property {Number} lastAnimationFrame
           * @type {Number}
           */this.lastAnimationFrame=null;this[s]=this[s].bind(this)}attach(){this.draggable.on("sortable:sorted",this[s])}detach(){this.draggable.off("sortable:sorted",this[s])}getOptions(){return this.draggable.options.swapAnimation||{}}
/**
         * Sortable sorted handler
         * @param {SortableSortedEvent} sortableEvent
         * @private
         */[s]({oldIndex:e,newIndex:t,dragEvent:r}){const{source:n,over:o}=r;cancelAnimationFrame(this.lastAnimationFrame);this.lastAnimationFrame=requestAnimationFrame((()=>{e>=t?animate(n,o,this.options):animate(o,n,this.options)}))}}t.default=SwapAnimation;
/**
       * Animates two elements
       * @param {HTMLElement} from
       * @param {HTMLElement} to
       * @param {Object} options
       * @param {Number} options.duration
       * @param {String} options.easingFunction
       * @param {String} options.horizontal
       * @private
       */function animate(e,t,{duration:r,easingFunction:n,horizontal:o}){for(const r of[e,t])r.style.pointerEvents="none";if(o){const r=e.offsetWidth;e.style.transform=`translate3d(${r}px, 0, 0)`;t.style.transform=`translate3d(-${r}px, 0, 0)`}else{const r=e.offsetHeight;e.style.transform=`translate3d(0, ${r}px, 0)`;t.style.transform=`translate3d(0, -${r}px, 0)`}requestAnimationFrame((()=>{for(const o of[e,t]){o.addEventListener("transitionend",resetElementOnTransitionEnd);o.style.transition=`transform ${r}ms ${n}`;o.style.transform=""}}))}
/**
       * Resets animation style properties after animation has completed
       * @param {Event} event
       * @private
       */function resetElementOnTransitionEnd(e){e.target.style.transition="";e.target.style.pointerEvents="";e.target.removeEventListener("transitionend",resetElementOnTransitionEnd)}},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});t.defaultOptions=void 0;var n=r(17);var o=_interopRequireDefault(n);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}t.default=o.default;t.defaultOptions=n.defaultOptions},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=r(0);var o=_interopRequireDefault(n);var i=r(7);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const s=Symbol("onDragStart");const a=Symbol("onDragStop");const l=Symbol("onDragOver");const u=Symbol("onDragOut");const c=Symbol("onMirrorCreated");const d=Symbol("onMirrorDestroy");class Snappable extends o.default{
/**
         * Snappable constructor.
         * @constructs Snappable
         * @param {Draggable} draggable - Draggable instance
         */
constructor(e){super(e);this.firstSource=null;this.mirror=null;this[s]=this[s].bind(this);this[a]=this[a].bind(this);this[l]=this[l].bind(this);this[u]=this[u].bind(this);this[c]=this[c].bind(this);this[d]=this[d].bind(this)}attach(){this.draggable.on("drag:start",this[s]).on("drag:stop",this[a]).on("drag:over",this[l]).on("drag:out",this[u]).on("droppable:over",this[l]).on("droppable:out",this[u]).on("mirror:created",this[c]).on("mirror:destroy",this[d])}detach(){this.draggable.off("drag:start",this[s]).off("drag:stop",this[a]).off("drag:over",this[l]).off("drag:out",this[u]).off("droppable:over",this[l]).off("droppable:out",this[u]).off("mirror:created",this[c]).off("mirror:destroy",this[d])}
/**
         * Drag start handler
         * @private
         * @param {DragStartEvent} event - Drag start event
         */[s](e){e.canceled()||(this.firstSource=e.source)}
/**
         * Drag stop handler
         * @private
         * @param {DragStopEvent} event - Drag stop event
         */[a](){this.firstSource=null}
/**
         * Drag over handler
         * @private
         * @param {DragOverEvent|DroppableOverEvent} event - Drag over event
         */[l](e){if(e.canceled())return;const t=e.source||e.dragEvent.source;if(t===this.firstSource){this.firstSource=null;return}const r=new i.SnapInEvent({dragEvent:e,snappable:e.over||e.droppable});this.draggable.trigger(r);if(!r.canceled()){this.mirror&&(this.mirror.style.display="none");t.classList.remove(...this.draggable.getClassNamesFor("source:dragging"));t.classList.add(...this.draggable.getClassNamesFor("source:placed"));setTimeout((()=>{t.classList.remove(...this.draggable.getClassNamesFor("source:placed"))}),this.draggable.options.placedTimeout)}}
/**
         * Drag out handler
         * @private
         * @param {DragOutEvent|DroppableOutEvent} event - Drag out event
         */[u](e){if(e.canceled())return;const t=e.source||e.dragEvent.source;const r=new i.SnapOutEvent({dragEvent:e,snappable:e.over||e.droppable});this.draggable.trigger(r);if(!r.canceled()){this.mirror&&(this.mirror.style.display="");t.classList.add(...this.draggable.getClassNamesFor("source:dragging"))}}
/**
         * Mirror created handler
         * @param {MirrorCreatedEvent} mirrorEvent
         * @private
         */[c]({mirror:e}){this.mirror=e}
/**
         * Mirror destroy handler
         * @param {MirrorDestroyEvent} mirrorEvent
         * @private
         */[d](){this.mirror=null}}t.default=Snappable},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});t.SnapOutEvent=t.SnapInEvent=t.SnapEvent=void 0;var n=r(1);var o=_interopRequireDefault(n);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}class SnapEvent extends o.default{
/**
         * Drag event that triggered this snap event
         * @property dragEvent
         * @type {DragEvent}
         * @readonly
         */
get dragEvent(){return this.data.dragEvent}
/**
         * Snappable element
         * @property snappable
         * @type {HTMLElement}
         * @readonly
         */get snappable(){return this.data.snappable}}t.SnapEvent=SnapEvent;SnapEvent.type="snap";class SnapInEvent extends SnapEvent{}t.SnapInEvent=SnapInEvent;SnapInEvent.type="snap:in";SnapInEvent.cancelable=true;class SnapOutEvent extends SnapEvent{}t.SnapOutEvent=SnapOutEvent;SnapOutEvent.type="snap:out";SnapOutEvent.cancelable=true},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=r(7);Object.keys(n).forEach((function(e){"default"!==e&&"__esModule"!==e&&Object.defineProperty(t,e,{enumerable:true,get:function(){return n[e]}})}));var o=r(19);var i=_interopRequireDefault(o);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}t.default=i.default},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});t.defaultOptions=void 0;var n=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e};var o=r(0);var i=_interopRequireDefault(o);var s=r(2);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const a=Symbol("onMirrorCreated");const l=Symbol("onMirrorDestroy");const u=Symbol("onDragOver");const c=Symbol("resize");
/**
       * ResizeMirror default options
       * @property {Object} defaultOptions
       * @type {Object}
       */const d=t.defaultOptions={};class ResizeMirror extends i.default{
/**
         * ResizeMirror constructor.
         * @constructs ResizeMirror
         * @param {Draggable} draggable - Draggable instance
         */
constructor(e){super(e);
/**
           * ResizeMirror options
           * @property {Object} options
           * @type {Object}
           */this.options=n({},d,this.getOptions());this.lastWidth=0;this.lastHeight=0;this.mirror=null;this[a]=this[a].bind(this);this[l]=this[l].bind(this);this[u]=this[u].bind(this)}attach(){this.draggable.on("mirror:created",this[a]).on("drag:over",this[u]).on("drag:over:container",this[u])}detach(){this.draggable.off("mirror:created",this[a]).off("mirror:destroy",this[l]).off("drag:over",this[u]).off("drag:over:container",this[u])}getOptions(){return this.draggable.options.resizeMirror||{}}
/**
         * Mirror created handler
         * @param {MirrorCreatedEvent} mirrorEvent
         * @private
         */[a]({mirror:e}){this.mirror=e}
/**
         * Mirror destroy handler
         * @param {MirrorDestroyEvent} mirrorEvent
         * @private
         */[l](){this.mirror=null}
/**
         * Drag over handler
         * @param {DragOverEvent | DragOverContainer} dragEvent
         * @private
         */[u](e){this[c](e)}
/**
         * Resize function for
         * @param {DragOverEvent | DragOverContainer} dragEvent
         * @private
         */[c]({overContainer:e,over:t}){requestAnimationFrame((()=>{if(!this.mirror.parentNode)return;this.mirror.parentNode!==e&&e.appendChild(this.mirror);const r=t||this.draggable.getDraggableElementsForContainer(e)[0];r&&(0,s.requestNextAnimationFrame)((()=>{const e=r.getBoundingClientRect();if(this.lastHeight!==e.height||this.lastWidth!==e.width){this.mirror.style.width=`${e.width}px`;this.mirror.style.height=`${e.height}px`;this.lastWidth=e.width;this.lastHeight=e.height}}))}))}}t.default=ResizeMirror},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});t.defaultOptions=void 0;var n=r(22);var o=_interopRequireDefault(n);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}t.default=o.default;t.defaultOptions=n.defaultOptions},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=r(0);var o=_interopRequireDefault(n);var i=r(2);var s=r(8);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const a=Symbol("onDragMove");const l=Symbol("onDragStop");const u=Symbol("onRequestAnimationFrame");class Collidable extends o.default{
/**
         * Collidable constructor.
         * @constructs Collidable
         * @param {Draggable} draggable - Draggable instance
         */
constructor(e){super(e);
/**
           * Keeps track of currently colliding elements
           * @property {HTMLElement|null} currentlyCollidingElement
           * @type {HTMLElement|null}
           */this.currentlyCollidingElement=null;
/**
           * Keeps track of currently colliding elements
           * @property {HTMLElement|null} lastCollidingElement
           * @type {HTMLElement|null}
           */this.lastCollidingElement=null;
/**
           * Animation frame for finding colliding elements
           * @property {Number|null} currentAnimationFrame
           * @type {Number|null}
           */this.currentAnimationFrame=null;this[a]=this[a].bind(this);this[l]=this[l].bind(this);this[u]=this[u].bind(this)}attach(){this.draggable.on("drag:move",this[a]).on("drag:stop",this[l])}detach(){this.draggable.off("drag:move",this[a]).off("drag:stop",this[l])}getCollidables(){const e=this.draggable.options.collidables;return"string"===typeof e?Array.prototype.slice.call(document.querySelectorAll(e)):e instanceof NodeList||e instanceof Array?Array.prototype.slice.call(e):e instanceof HTMLElement?[e]:"function"===typeof e?e():[]}
/**
         * Drag move handler
         * @private
         * @param {DragMoveEvent} event - Drag move event
         */[a](e){const t=e.sensorEvent.target;this.currentAnimationFrame=requestAnimationFrame(this[u](t));this.currentlyCollidingElement&&e.cancel();const r=new s.CollidableInEvent({dragEvent:e,collidingElement:this.currentlyCollidingElement});const n=new s.CollidableOutEvent({dragEvent:e,collidingElement:this.lastCollidingElement});const o=Boolean(this.currentlyCollidingElement&&this.lastCollidingElement!==this.currentlyCollidingElement);const i=Boolean(!this.currentlyCollidingElement&&this.lastCollidingElement);if(o){this.lastCollidingElement&&this.draggable.trigger(n);this.draggable.trigger(r)}else i&&this.draggable.trigger(n);this.lastCollidingElement=this.currentlyCollidingElement}
/**
         * Drag stop handler
         * @private
         * @param {DragStopEvent} event - Drag stop event
         */[l](e){const t=this.currentlyCollidingElement||this.lastCollidingElement;const r=new s.CollidableOutEvent({dragEvent:e,collidingElement:t});t&&this.draggable.trigger(r);this.lastCollidingElement=null;this.currentlyCollidingElement=null}
/**
         * Animation frame function
         * @private
         * @param {HTMLElement} target - Current move target
         * @return {Function}
         */[u](e){return()=>{const t=this.getCollidables();this.currentlyCollidingElement=(0,i.closest)(e,(e=>t.includes(e)))}}}t.default=Collidable},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});t.CollidableOutEvent=t.CollidableInEvent=t.CollidableEvent=void 0;var n=r(1);var o=_interopRequireDefault(n);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}class CollidableEvent extends o.default{
/**
         * Drag event that triggered this colliable event
         * @property dragEvent
         * @type {DragEvent}
         * @readonly
         */
get dragEvent(){return this.data.dragEvent}}t.CollidableEvent=CollidableEvent;CollidableEvent.type="collidable";class CollidableInEvent extends CollidableEvent{
/**
         * Element you are currently colliding with
         * @property collidingElement
         * @type {HTMLElement}
         * @readonly
         */
get collidingElement(){return this.data.collidingElement}}t.CollidableInEvent=CollidableInEvent;CollidableInEvent.type="collidable:in";class CollidableOutEvent extends CollidableEvent{
/**
         * Element you were previously colliding with
         * @property collidingElement
         * @type {HTMLElement}
         * @readonly
         */
get collidingElement(){return this.data.collidingElement}}t.CollidableOutEvent=CollidableOutEvent;CollidableOutEvent.type="collidable:out"},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=r(8);Object.keys(n).forEach((function(e){"default"!==e&&"__esModule"!==e&&Object.defineProperty(t,e,{enumerable:true,get:function(){return n[e]}})}));var o=r(24);var i=_interopRequireDefault(o);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}t.default=i.default},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=r(26);Object.defineProperty(t,"Collidable",{enumerable:true,get:function(){return _interopRequireDefault(n).default}});var o=r(23);Object.defineProperty(t,"ResizeMirror",{enumerable:true,get:function(){return _interopRequireDefault(o).default}});Object.defineProperty(t,"defaultResizeMirrorOptions",{enumerable:true,get:function(){return o.defaultOptions}});var i=r(21);Object.defineProperty(t,"Snappable",{enumerable:true,get:function(){return _interopRequireDefault(i).default}});var s=r(18);Object.defineProperty(t,"SwapAnimation",{enumerable:true,get:function(){return _interopRequireDefault(s).default}});Object.defineProperty(t,"defaultSwapAnimationOptions",{enumerable:true,get:function(){return s.defaultOptions}});var a=r(16);Object.defineProperty(t,"SortAnimation",{enumerable:true,get:function(){return _interopRequireDefault(a).default}});Object.defineProperty(t,"defaultSortAnimationOptions",{enumerable:true,get:function(){return a.defaultOptions}});function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e};var o=r(5);var i=_interopRequireDefault(o);var s=r(9);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const a=Symbol("onDragStart");const l=Symbol("onDragOverContainer");const u=Symbol("onDragOver");const c=Symbol("onDragStop");
/**
       * Returns announcement message when a Draggable element has been sorted with another Draggable element
       * or moved into a new container
       * @param {SortableSortedEvent} sortableEvent
       * @return {String}
       */function onSortableSortedDefaultAnnouncement({dragEvent:e}){const t=e.source.textContent.trim()||e.source.id||"sortable element";if(e.over){const r=e.over.textContent.trim()||e.over.id||"sortable element";const n=e.source.compareDocumentPosition(e.over)&Node.DOCUMENT_POSITION_FOLLOWING;return n?`Placed ${t} after ${r}`:`Placed ${t} before ${r}`}return`Placed ${t} into a different container`}const d={"sortable:sorted":onSortableSortedDefaultAnnouncement};class Sortable extends i.default{
/**
         * Sortable constructor.
         * @constructs Sortable
         * @param {HTMLElement[]|NodeList|HTMLElement} containers - Sortable containers
         * @param {Object} options - Options for Sortable
         */
constructor(e=[],t={}){super(e,n({},t,{announcements:n({},d,t.announcements||{})}));
/**
           * start index of source on drag start
           * @property startIndex
           * @type {Number}
           */this.startIndex=null;
/**
           * start container on drag start
           * @property startContainer
           * @type {HTMLElement}
           * @default null
           */this.startContainer=null;this[a]=this[a].bind(this);this[l]=this[l].bind(this);this[u]=this[u].bind(this);this[c]=this[c].bind(this);this.on("drag:start",this[a]).on("drag:over:container",this[l]).on("drag:over",this[u]).on("drag:stop",this[c])}destroy(){super.destroy();this.off("drag:start",this[a]).off("drag:over:container",this[l]).off("drag:over",this[u]).off("drag:stop",this[c])}
/**
         * Returns true index of element within its container during drag operation, i.e. excluding mirror and original source
         * @param {HTMLElement} element - An element
         * @return {Number}
         */index(e){return this.getSortableElementsForContainer(e.parentNode).indexOf(e)}
/**
         * Returns sortable elements for a given container, excluding the mirror and
         * original source element if present
         * @param {HTMLElement} container
         * @return {HTMLElement[]}
         */getSortableElementsForContainer(e){const t=e.querySelectorAll(this.options.draggable);return[...t].filter((t=>t!==this.originalSource&&t!==this.mirror&&t.parentNode===e))}
/**
         * Drag start handler
         * @private
         * @param {DragStartEvent} event - Drag start event
         */[a](e){this.startContainer=e.source.parentNode;this.startIndex=this.index(e.source);const t=new s.SortableStartEvent({dragEvent:e,startIndex:this.startIndex,startContainer:this.startContainer});this.trigger(t);t.canceled()&&e.cancel()}
/**
         * Drag over container handler
         * @private
         * @param {DragOverContainerEvent} event - Drag over container event
         */[l](e){if(e.canceled())return;const{source:t,over:r,overContainer:n}=e;const o=this.index(t);const i=new s.SortableSortEvent({dragEvent:e,currentIndex:o,source:t,over:r});this.trigger(i);if(i.canceled())return;const a=this.getSortableElementsForContainer(n);const l=move({source:t,over:r,overContainer:n,children:a});if(!l)return;const{oldContainer:u,newContainer:c}=l;const d=this.index(e.source);const h=new s.SortableSortedEvent({dragEvent:e,oldIndex:o,newIndex:d,oldContainer:u,newContainer:c});this.trigger(h)}
/**
         * Drag over handler
         * @private
         * @param {DragOverEvent} event - Drag over event
         */[u](e){if(e.over===e.originalSource||e.over===e.source)return;const{source:t,over:r,overContainer:n}=e;const o=this.index(t);const i=new s.SortableSortEvent({dragEvent:e,currentIndex:o,source:t,over:r});this.trigger(i);if(i.canceled())return;const a=this.getDraggableElementsForContainer(n);const l=move({source:t,over:r,overContainer:n,children:a});if(!l)return;const{oldContainer:u,newContainer:c}=l;const d=this.index(t);const h=new s.SortableSortedEvent({dragEvent:e,oldIndex:o,newIndex:d,oldContainer:u,newContainer:c});this.trigger(h)}
/**
         * Drag stop handler
         * @private
         * @param {DragStopEvent} event - Drag stop event
         */[c](e){const t=new s.SortableStopEvent({dragEvent:e,oldIndex:this.startIndex,newIndex:this.index(e.source),oldContainer:this.startContainer,newContainer:e.source.parentNode});this.trigger(t);this.startIndex=null;this.startContainer=null}}t.default=Sortable;function index(e){return Array.prototype.indexOf.call(e.parentNode.children,e)}function move({source:e,over:t,overContainer:r,children:n}){const o=!n.length;const i=e.parentNode!==r;const s=t&&e.parentNode===t.parentNode;return o?moveInsideEmptyContainer(e,r):s?moveWithinContainer(e,t):i?moveOutsideContainer(e,t,r):null}function moveInsideEmptyContainer(e,t){const r=e.parentNode;t.appendChild(e);return{oldContainer:r,newContainer:t}}function moveWithinContainer(e,t){const r=index(e);const n=index(t);r<n?e.parentNode.insertBefore(e,t.nextElementSibling):e.parentNode.insertBefore(e,t);return{oldContainer:e.parentNode,newContainer:e.parentNode}}function moveOutsideContainer(e,t,r){const n=e.parentNode;t?t.parentNode.insertBefore(e,t):r.appendChild(e);return{oldContainer:n,newContainer:e.parentNode}}},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});t.SortableStopEvent=t.SortableSortedEvent=t.SortableSortEvent=t.SortableStartEvent=t.SortableEvent=void 0;var n=r(1);var o=_interopRequireDefault(n);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}class SortableEvent extends o.default{
/**
         * Original drag event that triggered this sortable event
         * @property dragEvent
         * @type {DragEvent}
         * @readonly
         */
get dragEvent(){return this.data.dragEvent}}t.SortableEvent=SortableEvent;SortableEvent.type="sortable";class SortableStartEvent extends SortableEvent{
/**
         * Start index of source on sortable start
         * @property startIndex
         * @type {Number}
         * @readonly
         */
get startIndex(){return this.data.startIndex}
/**
         * Start container on sortable start
         * @property startContainer
         * @type {HTMLElement}
         * @readonly
         */get startContainer(){return this.data.startContainer}}t.SortableStartEvent=SortableStartEvent;SortableStartEvent.type="sortable:start";SortableStartEvent.cancelable=true;class SortableSortEvent extends SortableEvent{
/**
         * Index of current draggable element
         * @property currentIndex
         * @type {Number}
         * @readonly
         */
get currentIndex(){return this.data.currentIndex}
/**
         * Draggable element you are hovering over
         * @property over
         * @type {HTMLElement}
         * @readonly
         */get over(){return this.data.over}
/**
         * Draggable container element you are hovering over
         * @property overContainer
         * @type {HTMLElement}
         * @readonly
         */get overContainer(){return this.data.dragEvent.overContainer}}t.SortableSortEvent=SortableSortEvent;SortableSortEvent.type="sortable:sort";SortableSortEvent.cancelable=true;class SortableSortedEvent extends SortableEvent{
/**
         * Index of last sorted event
         * @property oldIndex
         * @type {Number}
         * @readonly
         */
get oldIndex(){return this.data.oldIndex}
/**
         * New index of this sorted event
         * @property newIndex
         * @type {Number}
         * @readonly
         */get newIndex(){return this.data.newIndex}
/**
         * Old container of draggable element
         * @property oldContainer
         * @type {HTMLElement}
         * @readonly
         */get oldContainer(){return this.data.oldContainer}
/**
         * New container of draggable element
         * @property newContainer
         * @type {HTMLElement}
         * @readonly
         */get newContainer(){return this.data.newContainer}}t.SortableSortedEvent=SortableSortedEvent;SortableSortedEvent.type="sortable:sorted";class SortableStopEvent extends SortableEvent{
/**
         * Original index on sortable start
         * @property oldIndex
         * @type {Number}
         * @readonly
         */
get oldIndex(){return this.data.oldIndex}
/**
         * New index of draggable element
         * @property newIndex
         * @type {Number}
         * @readonly
         */get newIndex(){return this.data.newIndex}
/**
         * Original container of draggable element
         * @property oldContainer
         * @type {HTMLElement}
         * @readonly
         */get oldContainer(){return this.data.oldContainer}
/**
         * New container of draggable element
         * @property newContainer
         * @type {HTMLElement}
         * @readonly
         */get newContainer(){return this.data.newContainer}}t.SortableStopEvent=SortableStopEvent;SortableStopEvent.type="sortable:stop"},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=r(9);Object.keys(n).forEach((function(e){"default"!==e&&"__esModule"!==e&&Object.defineProperty(t,e,{enumerable:true,get:function(){return n[e]}})}));var o=r(28);var i=_interopRequireDefault(o);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}t.default=i.default},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e};var o=r(5);var i=_interopRequireDefault(o);var s=r(10);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const a=Symbol("onDragStart");const l=Symbol("onDragOver");const u=Symbol("onDragStop");
/**
       * Returns an announcement message when the Draggable element is swapped with another draggable element
       * @param {SwappableSwappedEvent} swappableEvent
       * @return {String}
       */function onSwappableSwappedDefaultAnnouncement({dragEvent:e,swappedElement:t}){const r=e.source.textContent.trim()||e.source.id||"swappable element";const n=t.textContent.trim()||t.id||"swappable element";return`Swapped ${r} with ${n}`}const c={"swappabled:swapped":onSwappableSwappedDefaultAnnouncement};class Swappable extends i.default{
/**
         * Swappable constructor.
         * @constructs Swappable
         * @param {HTMLElement[]|NodeList|HTMLElement} containers - Swappable containers
         * @param {Object} options - Options for Swappable
         */
constructor(e=[],t={}){super(e,n({},t,{announcements:n({},c,t.announcements||{})}));
/**
           * Last draggable element that was dragged over
           * @property lastOver
           * @type {HTMLElement}
           */this.lastOver=null;this[a]=this[a].bind(this);this[l]=this[l].bind(this);this[u]=this[u].bind(this);this.on("drag:start",this[a]).on("drag:over",this[l]).on("drag:stop",this[u])}destroy(){super.destroy();this.off("drag:start",this._onDragStart).off("drag:over",this._onDragOver).off("drag:stop",this._onDragStop)}
/**
         * Drag start handler
         * @private
         * @param {DragStartEvent} event - Drag start event
         */[a](e){const t=new s.SwappableStartEvent({dragEvent:e});this.trigger(t);t.canceled()&&e.cancel()}
/**
         * Drag over handler
         * @private
         * @param {DragOverEvent} event - Drag over event
         */[l](e){if(e.over===e.originalSource||e.over===e.source||e.canceled())return;const t=new s.SwappableSwapEvent({dragEvent:e,over:e.over,overContainer:e.overContainer});this.trigger(t);if(t.canceled())return;this.lastOver&&this.lastOver!==e.over&&swap(this.lastOver,e.source);this.lastOver===e.over?this.lastOver=null:this.lastOver=e.over;swap(e.source,e.over);const r=new s.SwappableSwappedEvent({dragEvent:e,swappedElement:e.over});this.trigger(r)}
/**
         * Drag stop handler
         * @private
         * @param {DragStopEvent} event - Drag stop event
         */[u](e){const t=new s.SwappableStopEvent({dragEvent:e});this.trigger(t);this.lastOver=null}}t.default=Swappable;function withTempElement(e){const t=document.createElement("div");e(t);t.parentNode.removeChild(t)}function swap(e,t){const r=t.parentNode;const n=e.parentNode;withTempElement((o=>{n.insertBefore(o,e);r.insertBefore(e,t);n.insertBefore(t,o)}))}},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});t.SwappableStopEvent=t.SwappableSwappedEvent=t.SwappableSwapEvent=t.SwappableStartEvent=t.SwappableEvent=void 0;var n=r(1);var o=_interopRequireDefault(n);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}class SwappableEvent extends o.default{
/**
         * Original drag event that triggered this swappable event
         * @property dragEvent
         * @type {DragEvent}
         * @readonly
         */
get dragEvent(){return this.data.dragEvent}}t.SwappableEvent=SwappableEvent;SwappableEvent.type="swappable";class SwappableStartEvent extends SwappableEvent{}t.SwappableStartEvent=SwappableStartEvent;SwappableStartEvent.type="swappable:start";SwappableStartEvent.cancelable=true;class SwappableSwapEvent extends SwappableEvent{
/**
         * Draggable element you are over
         * @property over
         * @type {HTMLElement}
         * @readonly
         */
get over(){return this.data.over}
/**
         * Draggable container you are over
         * @property overContainer
         * @type {HTMLElement}
         * @readonly
         */get overContainer(){return this.data.overContainer}}t.SwappableSwapEvent=SwappableSwapEvent;SwappableSwapEvent.type="swappable:swap";SwappableSwapEvent.cancelable=true;class SwappableSwappedEvent extends SwappableEvent{
/**
         * The draggable element that you swapped with
         * @property swappedElement
         * @type {HTMLElement}
         * @readonly
         */
get swappedElement(){return this.data.swappedElement}}t.SwappableSwappedEvent=SwappableSwappedEvent;SwappableSwappedEvent.type="swappable:swapped";class SwappableStopEvent extends SwappableEvent{}t.SwappableStopEvent=SwappableStopEvent;SwappableStopEvent.type="swappable:stop"},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=r(10);Object.keys(n).forEach((function(e){"default"!==e&&"__esModule"!==e&&Object.defineProperty(t,e,{enumerable:true,get:function(){return n[e]}})}));var o=r(31);var i=_interopRequireDefault(o);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}t.default=i.default},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e};var o=r(2);var i=r(5);var s=_interopRequireDefault(i);var a=r(11);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const l=Symbol("onDragStart");const u=Symbol("onDragMove");const c=Symbol("onDragStop");const d=Symbol("dropInDropZone");const h=Symbol("returnToOriginalDropzone");const p=Symbol("closestDropzone");const g=Symbol("getDropzones");
/**
       * Returns an announcement message when the Draggable element is dropped into a dropzone element
       * @param {DroppableDroppedEvent} droppableEvent
       * @return {String}
       */function onDroppableDroppedDefaultAnnouncement({dragEvent:e,dropzone:t}){const r=e.source.textContent.trim()||e.source.id||"draggable element";const n=t.textContent.trim()||t.id||"droppable element";return`Dropped ${r} into ${n}`}
/**
       * Returns an announcement message when the Draggable element has returned to its original dropzone element
       * @param {DroppableReturnedEvent} droppableEvent
       * @return {String}
       */function onDroppableReturnedDefaultAnnouncement({dragEvent:e,dropzone:t}){const r=e.source.textContent.trim()||e.source.id||"draggable element";const n=t.textContent.trim()||t.id||"droppable element";return`Returned ${r} from ${n}`}const f={"droppable:dropped":onDroppableDroppedDefaultAnnouncement,"droppable:returned":onDroppableReturnedDefaultAnnouncement};const v={"droppable:active":"draggable-dropzone--active","droppable:occupied":"draggable-dropzone--occupied"};const b={dropzone:".draggable-droppable"};class Droppable extends s.default{
/**
         * Droppable constructor.
         * @constructs Droppable
         * @param {HTMLElement[]|NodeList|HTMLElement} containers - Droppable containers
         * @param {Object} options - Options for Droppable
         */
constructor(e=[],t={}){super(e,n({},b,t,{classes:n({},v,t.classes||{}),announcements:n({},f,t.announcements||{})}));
/**
           * All dropzone elements on drag start
           * @property dropzones
           * @type {HTMLElement[]}
           */this.dropzones=null;
/**
           * Last dropzone element that the source was dropped into
           * @property lastDropzone
           * @type {HTMLElement}
           */this.lastDropzone=null;
/**
           * Initial dropzone element that the source was drag from
           * @property initialDropzone
           * @type {HTMLElement}
           */this.initialDropzone=null;this[l]=this[l].bind(this);this[u]=this[u].bind(this);this[c]=this[c].bind(this);this.on("drag:start",this[l]).on("drag:move",this[u]).on("drag:stop",this[c])}destroy(){super.destroy();this.off("drag:start",this[l]).off("drag:move",this[u]).off("drag:stop",this[c])}
/**
         * Drag start handler
         * @private
         * @param {DragStartEvent} event - Drag start event
         */[l](e){if(e.canceled())return;this.dropzones=[...this[g]()];const t=(0,o.closest)(e.sensorEvent.target,this.options.dropzone);if(!t){e.cancel();return}const r=new a.DroppableStartEvent({dragEvent:e,dropzone:t});this.trigger(r);if(r.canceled())e.cancel();else{this.initialDropzone=t;for(const e of this.dropzones)e.classList.contains(this.getClassNameFor("droppable:occupied"))||e.classList.add(...this.getClassNamesFor("droppable:active"))}}
/**
         * Drag move handler
         * @private
         * @param {DragMoveEvent} event - Drag move event
         */[u](e){if(e.canceled())return;const t=this[p](e.sensorEvent.target);const r=t&&!t.classList.contains(this.getClassNameFor("droppable:occupied"));if(r&&this[d](e,t))this.lastDropzone=t;else if((!t||t===this.initialDropzone)&&this.lastDropzone){this[h](e);this.lastDropzone=null}}
/**
         * Drag stop handler
         * @private
         * @param {DragStopEvent} event - Drag stop event
         */[c](e){const t=new a.DroppableStopEvent({dragEvent:e,dropzone:this.lastDropzone||this.initialDropzone});this.trigger(t);const r=this.getClassNamesFor("droppable:occupied");for(const e of this.dropzones)e.classList.remove(...this.getClassNamesFor("droppable:active"));this.lastDropzone&&this.lastDropzone!==this.initialDropzone&&this.initialDropzone.classList.remove(...r);this.dropzones=null;this.lastDropzone=null;this.initialDropzone=null}
/**
         * Drops a draggable element into a dropzone element
         * @private
         * @param {DragMoveEvent} event - Drag move event
         * @param {HTMLElement} dropzone - Dropzone element to drop draggable into
         */[d](e,t){const r=new a.DroppableDroppedEvent({dragEvent:e,dropzone:t});this.trigger(r);if(r.canceled())return false;const n=this.getClassNamesFor("droppable:occupied");this.lastDropzone&&this.lastDropzone.classList.remove(...n);t.appendChild(e.source);t.classList.add(...n);return true}
/**
         * Moves the previously dropped element back into its original dropzone
         * @private
         * @param {DragMoveEvent} event - Drag move event
         */[h](e){const t=new a.DroppableReturnedEvent({dragEvent:e,dropzone:this.lastDropzone});this.trigger(t);if(!t.canceled()){this.initialDropzone.appendChild(e.source);this.lastDropzone.classList.remove(...this.getClassNamesFor("droppable:occupied"))}}
/**
         * Returns closest dropzone element for even target
         * @private
         * @param {HTMLElement} target - Event target
         * @return {HTMLElement|null}
         */[p](e){return this.dropzones?(0,o.closest)(e,this.dropzones):null}[g](){const e=this.options.dropzone;return"string"===typeof e?document.querySelectorAll(e):e instanceof NodeList||e instanceof Array?e:"function"===typeof e?e():[]}}t.default=Droppable},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});t.DroppableStopEvent=t.DroppableReturnedEvent=t.DroppableDroppedEvent=t.DroppableStartEvent=t.DroppableEvent=void 0;var n=r(1);var o=_interopRequireDefault(n);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}class DroppableEvent extends o.default{
/**
         * Original drag event that triggered this droppable event
         * @property dragEvent
         * @type {DragEvent}
         * @readonly
         */
get dragEvent(){return this.data.dragEvent}}t.DroppableEvent=DroppableEvent;DroppableEvent.type="droppable";class DroppableStartEvent extends DroppableEvent{
/**
         * The initial dropzone element of the currently dragging draggable element
         * @property dropzone
         * @type {HTMLElement}
         * @readonly
         */
get dropzone(){return this.data.dropzone}}t.DroppableStartEvent=DroppableStartEvent;DroppableStartEvent.type="droppable:start";DroppableStartEvent.cancelable=true;class DroppableDroppedEvent extends DroppableEvent{
/**
         * The dropzone element you dropped the draggable element into
         * @property dropzone
         * @type {HTMLElement}
         * @readonly
         */
get dropzone(){return this.data.dropzone}}t.DroppableDroppedEvent=DroppableDroppedEvent;DroppableDroppedEvent.type="droppable:dropped";DroppableDroppedEvent.cancelable=true;class DroppableReturnedEvent extends DroppableEvent{
/**
         * The dropzone element you dragged away from
         * @property dropzone
         * @type {HTMLElement}
         * @readonly
         */
get dropzone(){return this.data.dropzone}}t.DroppableReturnedEvent=DroppableReturnedEvent;DroppableReturnedEvent.type="droppable:returned";DroppableReturnedEvent.cancelable=true;class DroppableStopEvent extends DroppableEvent{
/**
         * The final dropzone element of the draggable element
         * @property dropzone
         * @type {HTMLElement}
         * @readonly
         */
get dropzone(){return this.data.dropzone}}t.DroppableStopEvent=DroppableStopEvent;DroppableStopEvent.type="droppable:stop";DroppableStopEvent.cancelable=true},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=r(11);Object.keys(n).forEach((function(e){"default"!==e&&"__esModule"!==e&&Object.defineProperty(t,e,{enumerable:true,get:function(){return n[e]}})}));var o=r(34);var i=_interopRequireDefault(o);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}t.default=i.default},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});class Emitter{constructor(){this.callbacks={}}
/**
         * Registers callbacks by event name
         * @param {String} type
         * @param {...Function} callbacks
         */on(e,...t){this.callbacks[e]||(this.callbacks[e]=[]);this.callbacks[e].push(...t);return this}
/**
         * Unregisters callbacks by event name
         * @param {String} type
         * @param {Function} callback
         */off(e,t){if(!this.callbacks[e])return null;const r=this.callbacks[e].slice(0);for(let n=0;n<r.length;n++)t===r[n]&&this.callbacks[e].splice(n,1);return this}
/**
         * Triggers event callbacks by event object
         * @param {AbstractEvent} event
         */trigger(e){if(!this.callbacks[e.type])return null;const t=[...this.callbacks[e.type]];const r=[];for(let n=t.length-1;n>=0;n--){const o=t[n];try{o(e)}catch(e){r.push(e)}}r.length&&console.error(`Draggable caught errors while triggering '${e.type}'`,r);return this}}t.default=Emitter},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=r(37);var o=_interopRequireDefault(n);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}t.default=o.default},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});t.defaultOptions=void 0;var n=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e};var o=r(2);var i=r(12);var s=r(38);var a=_interopRequireDefault(s);var l=r(6);var u=r(13);var c=r(14);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const d=Symbol("onDragStart");const h=Symbol("onDragMove");const p=Symbol("onDragStop");const g=Symbol("onDragPressure");const f={"drag:start":e=>`Picked up ${e.source.textContent.trim()||e.source.id||"draggable element"}`,"drag:stop":e=>`Released ${e.source.textContent.trim()||e.source.id||"draggable element"}`};const v={"container:dragging":"draggable-container--is-dragging","source:dragging":"draggable-source--is-dragging","source:placed":"draggable-source--placed","container:placed":"draggable-container--placed","body:dragging":"draggable--is-dragging","draggable:over":"draggable--over","container:over":"draggable-container--over","source:original":"draggable--original",mirror:"draggable-mirror"};const b=t.defaultOptions={draggable:".draggable-source",handle:null,delay:{},distance:0,placedTimeout:800,plugins:[],sensors:[],exclude:{plugins:[],sensors:[]}};class Draggable{
/**
         * Draggable constructor.
         * @constructs Draggable
         * @param {HTMLElement[]|NodeList|HTMLElement} containers - Draggable containers
         * @param {Object} options - Options for draggable
         */
/**
         * Default plugins draggable uses
         * @static
         * @property {Object} Plugins
         * @property {Announcement} Plugins.Announcement
         * @property {Focusable} Plugins.Focusable
         * @property {Mirror} Plugins.Mirror
         * @property {Scrollable} Plugins.Scrollable
         * @type {Object}
         */
constructor(e=[document.body],t={}){
/**
           * Draggable containers
           * @property containers
           * @type {HTMLElement[]}
           */
if(e instanceof NodeList||e instanceof Array)this.containers=[...e];else{if(!(e instanceof HTMLElement))throw new Error("Draggable containers are expected to be of type `NodeList`, `HTMLElement[]` or `HTMLElement`");this.containers=[e]}this.options=n({},b,t,{classes:n({},v,t.classes||{}),announcements:n({},f,t.announcements||{}),exclude:{plugins:t.exclude&&t.exclude.plugins||[],sensors:t.exclude&&t.exclude.sensors||[]}});
/**
           * Draggables event emitter
           * @property emitter
           * @type {Emitter}
           */this.emitter=new a.default;
/**
           * Current drag state
           * @property dragging
           * @type {Boolean}
           */this.dragging=false;
/**
           * Active plugins
           * @property plugins
           * @type {Plugin[]}
           */this.plugins=[];
/**
           * Active sensors
           * @property sensors
           * @type {Sensor[]}
           */this.sensors=[];this[d]=this[d].bind(this);this[h]=this[h].bind(this);this[p]=this[p].bind(this);this[g]=this[g].bind(this);document.addEventListener("drag:start",this[d],true);document.addEventListener("drag:move",this[h],true);document.addEventListener("drag:stop",this[p],true);document.addEventListener("drag:pressure",this[g],true);const r=Object.values(Draggable.Plugins).filter((e=>!this.options.exclude.plugins.includes(e)));const o=Object.values(Draggable.Sensors).filter((e=>!this.options.exclude.sensors.includes(e)));this.addPlugin(...r,...this.options.plugins);this.addSensor(...o,...this.options.sensors);const i=new u.DraggableInitializedEvent({draggable:this});this.on("mirror:created",(({mirror:e})=>this.mirror=e));this.on("mirror:destroy",(()=>this.mirror=null));this.trigger(i)}
/**
         * Default sensors draggable uses
         * @static
         * @property {Object} Sensors
         * @property {MouseSensor} Sensors.MouseSensor
         * @property {TouchSensor} Sensors.TouchSensor
         * @type {Object}
         */destroy(){document.removeEventListener("drag:start",this[d],true);document.removeEventListener("drag:move",this[h],true);document.removeEventListener("drag:stop",this[p],true);document.removeEventListener("drag:pressure",this[g],true);const e=new u.DraggableDestroyEvent({draggable:this});this.trigger(e);this.removePlugin(...this.plugins.map((e=>e.constructor)));this.removeSensor(...this.sensors.map((e=>e.constructor)))}
/**
         * Adds plugin to this draggable instance. This will end up calling the attach method of the plugin
         * @param {...typeof Plugin} plugins - Plugins that you want attached to draggable
         * @return {Draggable}
         * @example draggable.addPlugin(CustomA11yPlugin, CustomMirrorPlugin)
         */addPlugin(...e){const t=e.map((e=>new e(this)));t.forEach((e=>e.attach()));this.plugins=[...this.plugins,...t];return this}
/**
         * Removes plugins that are already attached to this draggable instance. This will end up calling
         * the detach method of the plugin
         * @param {...typeof Plugin} plugins - Plugins that you want detached from draggable
         * @return {Draggable}
         * @example draggable.removePlugin(MirrorPlugin, CustomMirrorPlugin)
         */removePlugin(...e){const t=this.plugins.filter((t=>e.includes(t.constructor)));t.forEach((e=>e.detach()));this.plugins=this.plugins.filter((t=>!e.includes(t.constructor)));return this}
/**
         * Adds sensors to this draggable instance. This will end up calling the attach method of the sensor
         * @param {...typeof Sensor} sensors - Sensors that you want attached to draggable
         * @return {Draggable}
         * @example draggable.addSensor(ForceTouchSensor, CustomSensor)
         */addSensor(...e){const t=e.map((e=>new e(this.containers,this.options)));t.forEach((e=>e.attach()));this.sensors=[...this.sensors,...t];return this}
/**
         * Removes sensors that are already attached to this draggable instance. This will end up calling
         * the detach method of the sensor
         * @param {...typeof Sensor} sensors - Sensors that you want attached to draggable
         * @return {Draggable}
         * @example draggable.removeSensor(TouchSensor, DragSensor)
         */removeSensor(...e){const t=this.sensors.filter((t=>e.includes(t.constructor)));t.forEach((e=>e.detach()));this.sensors=this.sensors.filter((t=>!e.includes(t.constructor)));return this}
/**
         * Adds container to this draggable instance
         * @param {...HTMLElement} containers - Containers you want to add to draggable
         * @return {Draggable}
         * @example draggable.addContainer(document.body)
         */addContainer(...e){this.containers=[...this.containers,...e];this.sensors.forEach((t=>t.addContainer(...e)));return this}
/**
         * Removes container from this draggable instance
         * @param {...HTMLElement} containers - Containers you want to remove from draggable
         * @return {Draggable}
         * @example draggable.removeContainer(document.body)
         */removeContainer(...e){this.containers=this.containers.filter((t=>!e.includes(t)));this.sensors.forEach((t=>t.removeContainer(...e)));return this}
/**
         * Adds listener for draggable events
         * @param {String} type - Event name
         * @param {...Function} callbacks - Event callbacks
         * @return {Draggable}
         * @example draggable.on('drag:start', (dragEvent) => dragEvent.cancel());
         */on(e,...t){this.emitter.on(e,...t);return this}
/**
         * Removes listener from draggable
         * @param {String} type - Event name
         * @param {Function} callback - Event callback
         * @return {Draggable}
         * @example draggable.off('drag:start', handlerFunction);
         */off(e,t){this.emitter.off(e,t);return this}
/**
         * Triggers draggable event
         * @param {AbstractEvent} event - Event instance
         * @return {Draggable}
         * @example draggable.trigger(event);
         */trigger(e){this.emitter.trigger(e);return this}
/**
         * Returns class name for class identifier
         * @param {String} name - Name of class identifier
         * @return {String|null}
         */getClassNameFor(e){return this.getClassNamesFor(e)[0]}getClassNamesFor(e){const t=this.options.classes[e];return t instanceof Array?t:"string"===typeof t||t instanceof String?[t]:[]}isDragging(){return Boolean(this.dragging)}getDraggableElements(){return this.containers.reduce(((e,t)=>[...e,...this.getDraggableElementsForContainer(t)]),[])}
/**
         * Returns draggable elements for a given container, excluding the mirror and
         * original source element if present
         * @param {HTMLElement} container
         * @return {HTMLElement[]}
         */getDraggableElementsForContainer(e){const t=e.querySelectorAll(this.options.draggable);return[...t].filter((e=>e!==this.originalSource&&e!==this.mirror))}
/**
         * Drag start handler
         * @private
         * @param {Event} event - DOM Drag event
         */[d](e){const t=getSensorEvent(e);const{target:r,container:i}=t;if(!this.containers.includes(i))return;if(this.options.handle&&r&&!(0,o.closest)(r,this.options.handle)){t.cancel();return}this.originalSource=(0,o.closest)(r,this.options.draggable);this.sourceContainer=i;if(!this.originalSource){t.cancel();return}if(this.lastPlacedSource&&this.lastPlacedContainer){clearTimeout(this.placedTimeoutID);this.lastPlacedSource.classList.remove(...this.getClassNamesFor("source:placed"));this.lastPlacedContainer.classList.remove(...this.getClassNamesFor("container:placed"))}this.source=this.originalSource.cloneNode(true);this.originalSource.parentNode.insertBefore(this.source,this.originalSource);this.originalSource.style.display="none";const s=new c.DragStartEvent({source:this.source,originalSource:this.originalSource,sourceContainer:i,sensorEvent:t});this.trigger(s);this.dragging=!s.canceled();if(s.canceled()){this.source.parentNode.removeChild(this.source);this.originalSource.style.display=null}else{this.originalSource.classList.add(...this.getClassNamesFor("source:original"));this.source.classList.add(...this.getClassNamesFor("source:dragging"));this.sourceContainer.classList.add(...this.getClassNamesFor("container:dragging"));document.body.classList.add(...this.getClassNamesFor("body:dragging"));applyUserSelect(document.body,"none");requestAnimationFrame((()=>{const t=getSensorEvent(e);const r=t.clone({target:this.source});this[h](n({},e,{detail:r}))}))}}
/**
         * Drag move handler
         * @private
         * @param {Event} event - DOM Drag event
         */[h](e){if(!this.dragging)return;const t=getSensorEvent(e);const{container:r}=t;let n=t.target;const i=new c.DragMoveEvent({source:this.source,originalSource:this.originalSource,sourceContainer:r,sensorEvent:t});this.trigger(i);i.canceled()&&t.cancel();n=(0,o.closest)(n,this.options.draggable);const s=(0,o.closest)(t.target,this.containers);const a=t.overContainer||s;const l=this.currentOverContainer&&a!==this.currentOverContainer;const u=this.currentOver&&n!==this.currentOver;const d=a&&this.currentOverContainer!==a;const h=s&&n&&this.currentOver!==n;if(u){const e=new c.DragOutEvent({source:this.source,originalSource:this.originalSource,sourceContainer:r,sensorEvent:t,over:this.currentOver,overContainer:this.currentOverContainer});this.currentOver.classList.remove(...this.getClassNamesFor("draggable:over"));this.currentOver=null;this.trigger(e)}if(l){const e=new c.DragOutContainerEvent({source:this.source,originalSource:this.originalSource,sourceContainer:r,sensorEvent:t,overContainer:this.currentOverContainer});this.currentOverContainer.classList.remove(...this.getClassNamesFor("container:over"));this.currentOverContainer=null;this.trigger(e)}if(d){a.classList.add(...this.getClassNamesFor("container:over"));const e=new c.DragOverContainerEvent({source:this.source,originalSource:this.originalSource,sourceContainer:r,sensorEvent:t,overContainer:a});this.currentOverContainer=a;this.trigger(e)}if(h){n.classList.add(...this.getClassNamesFor("draggable:over"));const e=new c.DragOverEvent({source:this.source,originalSource:this.originalSource,sourceContainer:r,sensorEvent:t,overContainer:a,over:n});this.currentOver=n;this.trigger(e)}}
/**
         * Drag stop handler
         * @private
         * @param {Event} event - DOM Drag event
         */[p](e){if(!this.dragging)return;this.dragging=false;const t=new c.DragStopEvent({source:this.source,originalSource:this.originalSource,sensorEvent:e.sensorEvent,sourceContainer:this.sourceContainer});this.trigger(t);this.source.parentNode.insertBefore(this.originalSource,this.source);this.source.parentNode.removeChild(this.source);this.originalSource.style.display="";this.source.classList.remove(...this.getClassNamesFor("source:dragging"));this.originalSource.classList.remove(...this.getClassNamesFor("source:original"));this.originalSource.classList.add(...this.getClassNamesFor("source:placed"));this.sourceContainer.classList.add(...this.getClassNamesFor("container:placed"));this.sourceContainer.classList.remove(...this.getClassNamesFor("container:dragging"));document.body.classList.remove(...this.getClassNamesFor("body:dragging"));applyUserSelect(document.body,"");this.currentOver&&this.currentOver.classList.remove(...this.getClassNamesFor("draggable:over"));this.currentOverContainer&&this.currentOverContainer.classList.remove(...this.getClassNamesFor("container:over"));this.lastPlacedSource=this.originalSource;this.lastPlacedContainer=this.sourceContainer;this.placedTimeoutID=setTimeout((()=>{this.lastPlacedSource&&this.lastPlacedSource.classList.remove(...this.getClassNamesFor("source:placed"));this.lastPlacedContainer&&this.lastPlacedContainer.classList.remove(...this.getClassNamesFor("container:placed"));this.lastPlacedSource=null;this.lastPlacedContainer=null}),this.options.placedTimeout);const r=new c.DragStoppedEvent({source:this.source,originalSource:this.originalSource,sensorEvent:e.sensorEvent,sourceContainer:this.sourceContainer});this.trigger(r);this.source=null;this.originalSource=null;this.currentOverContainer=null;this.currentOver=null;this.sourceContainer=null}
/**
         * Drag pressure handler
         * @private
         * @param {Event} event - DOM Drag event
         */[g](e){if(!this.dragging)return;const t=getSensorEvent(e);const r=this.source||(0,o.closest)(t.originalEvent.target,this.options.draggable);const n=new c.DragPressureEvent({sensorEvent:t,source:r,pressure:t.pressure});this.trigger(n)}}t.default=Draggable;Draggable.Plugins={Announcement:i.Announcement,Focusable:i.Focusable,Mirror:i.Mirror,Scrollable:i.Scrollable};Draggable.Sensors={MouseSensor:l.MouseSensor,TouchSensor:l.TouchSensor};function getSensorEvent(e){return e.detail}function applyUserSelect(e,t){e.style.webkitUserSelect=t;e.style.mozUserSelect=t;e.style.msUserSelect=t;e.style.oUserSelect=t;e.style.userSelect=t}},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=r(4);var o=_interopRequireDefault(n);var i=r(3);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const s=Symbol("onMouseForceWillBegin");const a=Symbol("onMouseForceDown");const l=Symbol("onMouseDown");const u=Symbol("onMouseForceChange");const c=Symbol("onMouseMove");const d=Symbol("onMouseUp");const h=Symbol("onMouseForceGlobalChange");class ForceTouchSensor extends o.default{
/**
         * ForceTouchSensor constructor.
         * @constructs ForceTouchSensor
         * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers
         * @param {Object} options - Options
         */
constructor(e=[],t={}){super(e,t);
/**
           * Draggable element needs to be remembered to unset the draggable attribute after drag operation has completed
           * @property mightDrag
           * @type {Boolean}
           */this.mightDrag=false;this[s]=this[s].bind(this);this[a]=this[a].bind(this);this[l]=this[l].bind(this);this[u]=this[u].bind(this);this[c]=this[c].bind(this);this[d]=this[d].bind(this)}attach(){for(const e of this.containers){e.addEventListener("webkitmouseforcewillbegin",this[s],false);e.addEventListener("webkitmouseforcedown",this[a],false);e.addEventListener("mousedown",this[l],true);e.addEventListener("webkitmouseforcechanged",this[u],false)}document.addEventListener("mousemove",this[c]);document.addEventListener("mouseup",this[d])}detach(){for(const e of this.containers){e.removeEventListener("webkitmouseforcewillbegin",this[s],false);e.removeEventListener("webkitmouseforcedown",this[a],false);e.removeEventListener("mousedown",this[l],true);e.removeEventListener("webkitmouseforcechanged",this[u],false)}document.removeEventListener("mousemove",this[c]);document.removeEventListener("mouseup",this[d])}
/**
         * Mouse force will begin handler
         * @private
         * @param {Event} event - Mouse force will begin event
         */[s](e){e.preventDefault();this.mightDrag=true}
/**
         * Mouse force down handler
         * @private
         * @param {Event} event - Mouse force down event
         */[a](e){if(this.dragging)return;const t=document.elementFromPoint(e.clientX,e.clientY);const r=e.currentTarget;const n=new i.DragStartSensorEvent({clientX:e.clientX,clientY:e.clientY,target:t,container:r,originalEvent:e});this.trigger(r,n);this.currentContainer=r;this.dragging=!n.canceled();this.mightDrag=false}
/**
         * Mouse up handler
         * @private
         * @param {Event} event - Mouse up event
         */[d](e){if(!this.dragging)return;const t=new i.DragStopSensorEvent({clientX:e.clientX,clientY:e.clientY,target:null,container:this.currentContainer,originalEvent:e});this.trigger(this.currentContainer,t);this.currentContainer=null;this.dragging=false;this.mightDrag=false}
/**
         * Mouse down handler
         * @private
         * @param {Event} event - Mouse down event
         */[l](e){if(this.mightDrag){e.stopPropagation();e.stopImmediatePropagation();e.preventDefault()}}
/**
         * Mouse move handler
         * @private
         * @param {Event} event - Mouse force will begin event
         */[c](e){if(!this.dragging)return;const t=document.elementFromPoint(e.clientX,e.clientY);const r=new i.DragMoveSensorEvent({clientX:e.clientX,clientY:e.clientY,target:t,container:this.currentContainer,originalEvent:e});this.trigger(this.currentContainer,r)}
/**
         * Mouse force change handler
         * @private
         * @param {Event} event - Mouse force change event
         */[u](e){if(this.dragging)return;const t=e.target;const r=e.currentTarget;const n=new i.DragPressureSensorEvent({pressure:e.webkitForce,clientX:e.clientX,clientY:e.clientY,target:t,container:r,originalEvent:e});this.trigger(r,n)}
/**
         * Mouse force global change handler
         * @private
         * @param {Event} event - Mouse force global change event
         */[h](e){if(!this.dragging)return;const t=e.target;const r=new i.DragPressureSensorEvent({pressure:e.webkitForce,clientX:e.clientX,clientY:e.clientY,target:t,container:this.currentContainer,originalEvent:e});this.trigger(this.currentContainer,r)}}t.default=ForceTouchSensor},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=r(40);var o=_interopRequireDefault(n);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}t.default=o.default},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=r(2);var o=r(4);var i=_interopRequireDefault(o);var s=r(3);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const a=Symbol("onMouseDown");const l=Symbol("onMouseUp");const u=Symbol("onDragStart");const c=Symbol("onDragOver");const d=Symbol("onDragEnd");const h=Symbol("onDrop");const p=Symbol("reset");class DragSensor extends i.default{
/**
         * DragSensor constructor.
         * @constructs DragSensor
         * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers
         * @param {Object} options - Options
         */
constructor(e=[],t={}){super(e,t);
/**
           * Mouse down timer which will end up setting the draggable attribute, unless canceled
           * @property mouseDownTimeout
           * @type {Number}
           */this.mouseDownTimeout=null;
/**
           * Draggable element needs to be remembered to unset the draggable attribute after drag operation has completed
           * @property draggableElement
           * @type {HTMLElement}
           */this.draggableElement=null;
/**
           * Native draggable element could be links or images, their draggable state will be disabled during drag operation
           * @property nativeDraggableElement
           * @type {HTMLElement}
           */this.nativeDraggableElement=null;this[a]=this[a].bind(this);this[l]=this[l].bind(this);this[u]=this[u].bind(this);this[c]=this[c].bind(this);this[d]=this[d].bind(this);this[h]=this[h].bind(this)}attach(){document.addEventListener("mousedown",this[a],true)}detach(){document.removeEventListener("mousedown",this[a],true)}
/**
         * Drag start handler
         * @private
         * @param {Event} event - Drag start event
         */[u](e){e.dataTransfer.setData("text","");e.dataTransfer.effectAllowed=this.options.type;const t=document.elementFromPoint(e.clientX,e.clientY);this.currentContainer=(0,n.closest)(e.target,this.containers);if(!this.currentContainer)return;const r=new s.DragStartSensorEvent({clientX:e.clientX,clientY:e.clientY,target:t,container:this.currentContainer,originalEvent:e});setTimeout((()=>{this.trigger(this.currentContainer,r);r.canceled()?this.dragging=false:this.dragging=true}),0)}
/**
         * Drag over handler
         * @private
         * @param {Event} event - Drag over event
         */[c](e){if(!this.dragging)return;const t=document.elementFromPoint(e.clientX,e.clientY);const r=this.currentContainer;const n=new s.DragMoveSensorEvent({clientX:e.clientX,clientY:e.clientY,target:t,container:r,originalEvent:e});this.trigger(r,n);if(!n.canceled()){e.preventDefault();e.dataTransfer.dropEffect=this.options.type}}
/**
         * Drag end handler
         * @private
         * @param {Event} event - Drag end event
         */[d](e){if(!this.dragging)return;document.removeEventListener("mouseup",this[l],true);const t=document.elementFromPoint(e.clientX,e.clientY);const r=this.currentContainer;const n=new s.DragStopSensorEvent({clientX:e.clientX,clientY:e.clientY,target:t,container:r,originalEvent:e});this.trigger(r,n);this.dragging=false;this.startEvent=null;this[p]()}
/**
         * Drop handler
         * @private
         * @param {Event} event - Drop event
         */[h](e){e.preventDefault()}
/**
         * Mouse down handler
         * @private
         * @param {Event} event - Mouse down event
         */[a](e){if(e.target&&(e.target.form||e.target.contenteditable))return;const t=(0,n.closest)(e.target,(e=>e.draggable));if(t){t.draggable=false;this.nativeDraggableElement=t}document.addEventListener("mouseup",this[l],true);document.addEventListener("dragstart",this[u],false);document.addEventListener("dragover",this[c],false);document.addEventListener("dragend",this[d],false);document.addEventListener("drop",this[h],false);const r=(0,n.closest)(e.target,this.options.draggable);if(r){this.startEvent=e;this.mouseDownTimeout=setTimeout((()=>{r.draggable=true;this.draggableElement=r}),this.delay.drag)}}
/**
         * Mouse up handler
         * @private
         * @param {Event} event - Mouse up event
         */[l](){this[p]()}
/**
         * Mouse up handler
         * @private
         * @param {Event} event - Mouse up event
         */[p](){clearTimeout(this.mouseDownTimeout);document.removeEventListener("mouseup",this[l],true);document.removeEventListener("dragstart",this[u],false);document.removeEventListener("dragover",this[c],false);document.removeEventListener("dragend",this[d],false);document.removeEventListener("drop",this[h],false);if(this.nativeDraggableElement){this.nativeDraggableElement.draggable=true;this.nativeDraggableElement=null}if(this.draggableElement){this.draggableElement.draggable=false;this.draggableElement=null}}}t.default=DragSensor},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=r(42);var o=_interopRequireDefault(n);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}t.default=o.default},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=r(2);var o=r(4);var i=_interopRequireDefault(o);var s=r(3);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const a=Symbol("onTouchStart");const l=Symbol("onTouchEnd");const u=Symbol("onTouchMove");const c=Symbol("startDrag");const d=Symbol("onDistanceChange");let h=false;window.addEventListener("touchmove",(e=>{h&&e.preventDefault()}),{passive:false});class TouchSensor extends i.default{
/**
         * TouchSensor constructor.
         * @constructs TouchSensor
         * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers
         * @param {Object} options - Options
         */
constructor(e=[],t={}){super(e,t);
/**
           * Closest scrollable container so accidental scroll can cancel long touch
           * @property currentScrollableParent
           * @type {HTMLElement}
           */this.currentScrollableParent=null;
/**
           * TimeoutID for managing delay
           * @property tapTimeout
           * @type {Number}
           */this.tapTimeout=null;
/**
           * touchMoved indicates if touch has moved during tapTimeout
           * @property touchMoved
           * @type {Boolean}
           */this.touchMoved=false;this.pageX=null;this.pageY=null;this[a]=this[a].bind(this);this[l]=this[l].bind(this);this[u]=this[u].bind(this);this[c]=this[c].bind(this);this[d]=this[d].bind(this)}attach(){document.addEventListener("touchstart",this[a])}detach(){document.removeEventListener("touchstart",this[a])}
/**
         * Touch start handler
         * @private
         * @param {Event} event - Touch start event
         */[a](e){const t=(0,n.closest)(e.target,this.containers);if(!t)return;const{distance:r=0}=this.options;const{delay:o}=this;const{pageX:i,pageY:s}=(0,n.touchCoords)(e);Object.assign(this,{pageX:i,pageY:s});this.onTouchStartAt=Date.now();this.startEvent=e;this.currentContainer=t;document.addEventListener("touchend",this[l]);document.addEventListener("touchcancel",this[l]);document.addEventListener("touchmove",this[d]);t.addEventListener("contextmenu",onContextMenu);r&&(h=true);this.tapTimeout=window.setTimeout((()=>{this[d]({touches:[{pageX:this.pageX,pageY:this.pageY}]})}),o.touch)}[c](){const e=this.startEvent;const t=this.currentContainer;const r=(0,n.touchCoords)(e);const o=new s.DragStartSensorEvent({clientX:r.pageX,clientY:r.pageY,target:e.target,container:t,originalEvent:e});this.trigger(this.currentContainer,o);this.dragging=!o.canceled();this.dragging&&document.addEventListener("touchmove",this[u]);h=this.dragging}
/**
         * Touch move handler prior to drag start.
         * @private
         * @param {Event} event - Touch move event
         */[d](e){const{distance:t}=this.options;const{startEvent:r,delay:o}=this;const i=(0,n.touchCoords)(r);const s=(0,n.touchCoords)(e);const a=Date.now()-this.onTouchStartAt;const l=(0,n.distance)(i.pageX,i.pageY,s.pageX,s.pageY);Object.assign(this,s);clearTimeout(this.tapTimeout);if(a<o.touch)document.removeEventListener("touchmove",this[d]);else if(l>=t){document.removeEventListener("touchmove",this[d]);this[c]()}}
/**
         * Mouse move handler while dragging
         * @private
         * @param {Event} event - Touch move event
         */[u](e){if(!this.dragging)return;const{pageX:t,pageY:r}=(0,n.touchCoords)(e);const o=document.elementFromPoint(t-window.scrollX,r-window.scrollY);const i=new s.DragMoveSensorEvent({clientX:t,clientY:r,target:o,container:this.currentContainer,originalEvent:e});this.trigger(this.currentContainer,i)}
/**
         * Touch end handler
         * @private
         * @param {Event} event - Touch end event
         */[l](e){clearTimeout(this.tapTimeout);h=false;document.removeEventListener("touchend",this[l]);document.removeEventListener("touchcancel",this[l]);document.removeEventListener("touchmove",this[d]);this.currentContainer&&this.currentContainer.removeEventListener("contextmenu",onContextMenu);if(!this.dragging)return;document.removeEventListener("touchmove",this[u]);const{pageX:t,pageY:r}=(0,n.touchCoords)(e);const o=document.elementFromPoint(t-window.scrollX,r-window.scrollY);e.preventDefault();const i=new s.DragStopSensorEvent({clientX:t,clientY:r,target:o,container:this.currentContainer,originalEvent:e});this.trigger(this.currentContainer,i);this.currentContainer=null;this.dragging=false;this.startEvent=null}}t.default=TouchSensor;function onContextMenu(e){e.preventDefault();e.stopPropagation()}},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=r(44);var o=_interopRequireDefault(n);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}t.default=o.default},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});t.DragPressureSensorEvent=t.DragStopSensorEvent=t.DragMoveSensorEvent=t.DragStartSensorEvent=t.SensorEvent=void 0;var n=r(1);var o=_interopRequireDefault(n);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}class SensorEvent extends o.default{
/**
         * Original browser event that triggered a sensor
         * @property originalEvent
         * @type {Event}
         * @readonly
         */
get originalEvent(){return this.data.originalEvent}
/**
         * Normalized clientX for both touch and mouse events
         * @property clientX
         * @type {Number}
         * @readonly
         */get clientX(){return this.data.clientX}
/**
         * Normalized clientY for both touch and mouse events
         * @property clientY
         * @type {Number}
         * @readonly
         */get clientY(){return this.data.clientY}
/**
         * Normalized target for both touch and mouse events
         * Returns the element that is behind cursor or touch pointer
         * @property target
         * @type {HTMLElement}
         * @readonly
         */get target(){return this.data.target}
/**
         * Container that initiated the sensor
         * @property container
         * @type {HTMLElement}
         * @readonly
         */get container(){return this.data.container}
/**
         * Trackpad pressure
         * @property pressure
         * @type {Number}
         * @readonly
         */get pressure(){return this.data.pressure}}t.SensorEvent=SensorEvent;class DragStartSensorEvent extends SensorEvent{}t.DragStartSensorEvent=DragStartSensorEvent;DragStartSensorEvent.type="drag:start";class DragMoveSensorEvent extends SensorEvent{}t.DragMoveSensorEvent=DragMoveSensorEvent;DragMoveSensorEvent.type="drag:move";class DragStopSensorEvent extends SensorEvent{}t.DragStopSensorEvent=DragStopSensorEvent;DragStopSensorEvent.type="drag:stop";class DragPressureSensorEvent extends SensorEvent{}t.DragPressureSensorEvent=DragPressureSensorEvent;DragPressureSensorEvent.type="drag:pressure"},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=r(2);var o=r(4);var i=_interopRequireDefault(o);var s=r(3);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const a=Symbol("onContextMenuWhileDragging");const l=Symbol("onMouseDown");const u=Symbol("onMouseMove");const c=Symbol("onMouseUp");const d=Symbol("startDrag");const h=Symbol("onDistanceChange");class MouseSensor extends i.default{
/**
         * MouseSensor constructor.
         * @constructs MouseSensor
         * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers
         * @param {Object} options - Options
         */
constructor(e=[],t={}){super(e,t);
/**
           * Mouse down timer which will end up triggering the drag start operation
           * @property mouseDownTimeout
           * @type {Number}
           */this.mouseDownTimeout=null;this.pageX=null;this.pageY=null;this[a]=this[a].bind(this);this[l]=this[l].bind(this);this[u]=this[u].bind(this);this[c]=this[c].bind(this);this[d]=this[d].bind(this);this[h]=this[h].bind(this)}attach(){document.addEventListener("mousedown",this[l],true)}detach(){document.removeEventListener("mousedown",this[l],true)}
/**
         * Mouse down handler
         * @private
         * @param {Event} event - Mouse down event
         */[l](e){if(0!==e.button||e.ctrlKey||e.metaKey)return;const t=(0,n.closest)(e.target,this.containers);if(!t)return;const{delay:r}=this;const{pageX:o,pageY:i}=e;Object.assign(this,{pageX:o,pageY:i});this.onMouseDownAt=Date.now();this.startEvent=e;this.currentContainer=t;document.addEventListener("mouseup",this[c]);document.addEventListener("dragstart",preventNativeDragStart);document.addEventListener("mousemove",this[h]);this.mouseDownTimeout=window.setTimeout((()=>{this[h]({pageX:this.pageX,pageY:this.pageY})}),r.mouse)}[d](){const e=this.startEvent;const t=this.currentContainer;const r=new s.DragStartSensorEvent({clientX:e.clientX,clientY:e.clientY,target:e.target,container:t,originalEvent:e});this.trigger(this.currentContainer,r);this.dragging=!r.canceled();if(this.dragging){document.addEventListener("contextmenu",this[a],true);document.addEventListener("mousemove",this[u])}}
/**
         * Detect change in distance, starting drag when both
         * delay and distance requirements are met
         * @private
         * @param {Event} event - Mouse move event
         */[h](e){const{pageX:t,pageY:r}=e;const{distance:o}=this.options;const{startEvent:i,delay:s}=this;Object.assign(this,{pageX:t,pageY:r});if(!this.currentContainer)return;const a=Date.now()-this.onMouseDownAt;const l=(0,n.distance)(i.pageX,i.pageY,t,r)||0;clearTimeout(this.mouseDownTimeout);if(a<s.mouse)document.removeEventListener("mousemove",this[h]);else if(l>=o){document.removeEventListener("mousemove",this[h]);this[d]()}}
/**
         * Mouse move handler
         * @private
         * @param {Event} event - Mouse move event
         */[u](e){if(!this.dragging)return;const t=document.elementFromPoint(e.clientX,e.clientY);const r=new s.DragMoveSensorEvent({clientX:e.clientX,clientY:e.clientY,target:t,container:this.currentContainer,originalEvent:e});this.trigger(this.currentContainer,r)}
/**
         * Mouse up handler
         * @private
         * @param {Event} event - Mouse up event
         */[c](e){clearTimeout(this.mouseDownTimeout);if(0!==e.button)return;document.removeEventListener("mouseup",this[c]);document.removeEventListener("dragstart",preventNativeDragStart);document.removeEventListener("mousemove",this[h]);if(!this.dragging)return;const t=document.elementFromPoint(e.clientX,e.clientY);const r=new s.DragStopSensorEvent({clientX:e.clientX,clientY:e.clientY,target:t,container:this.currentContainer,originalEvent:e});this.trigger(this.currentContainer,r);document.removeEventListener("contextmenu",this[a],true);document.removeEventListener("mousemove",this[u]);this.currentContainer=null;this.dragging=false;this.startEvent=null}
/**
         * Context menu handler
         * @private
         * @param {Event} event - Context menu event
         */[a](e){e.preventDefault()}}t.default=MouseSensor;function preventNativeDragStart(e){e.preventDefault()}},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=r(47);var o=_interopRequireDefault(n);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}t.default=o.default},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e};const o={mouse:0,drag:0,touch:100};class Sensor{
/**
         * Sensor constructor.
         * @constructs Sensor
         * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers
         * @param {Object} options - Options
         */
constructor(e=[],t={}){
/**
           * Current containers
           * @property containers
           * @type {HTMLElement[]}
           */
this.containers=[...e];
/**
           * Current options
           * @property options
           * @type {Object}
           */this.options=n({},t);
/**
           * Current drag state
           * @property dragging
           * @type {Boolean}
           */this.dragging=false;
/**
           * Current container
           * @property currentContainer
           * @type {HTMLElement}
           */this.currentContainer=null;
/**
           * The event of the initial sensor down
           * @property startEvent
           * @type {Event}
           */this.startEvent=null;
/**
           * The delay of each sensor
           * @property delay
           * @type {Object}
           */this.delay=calcDelay(t.delay)}attach(){return this}detach(){return this}
/**
         * Adds container to this sensor instance
         * @param {...HTMLElement} containers - Containers you want to add to this sensor
         * @example draggable.addContainer(document.body)
         */addContainer(...e){this.containers=[...this.containers,...e]}
/**
         * Removes container from this sensor instance
         * @param {...HTMLElement} containers - Containers you want to remove from this sensor
         * @example draggable.removeContainer(document.body)
         */removeContainer(...e){this.containers=this.containers.filter((t=>!e.includes(t)))}
/**
         * Triggers event on target element
         * @param {HTMLElement} element - Element to trigger event on
         * @param {SensorEvent} sensorEvent - Sensor event to trigger
         */trigger(e,t){const r=document.createEvent("Event");r.detail=t;r.initEvent(t.type,true,true);e.dispatchEvent(r);this.lastEvent=t;return t}}t.default=Sensor;
/**
       * Calculate the delay of each sensor through the delay in the options
       * @param {undefined|Number|Object} optionsDelay - the delay in the options
       * @return {Object}
       */function calcDelay(e){const t={};if(void 0===e)return n({},o);if("number"===typeof e){for(const r in o)o.hasOwnProperty(r)&&(t[r]=e);return t}for(const r in o)o.hasOwnProperty(r)&&(void 0===e[r]?t[r]=o[r]:t[r]=e[r]);return t}},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});t.default=touchCoords;
/**
       * Returns the first touch event found in touches or changedTouches of a touch events.
       * @param {TouchEvent} event a touch event
       * @return {Touch} a touch object
       */function touchCoords(e={}){const{touches:t,changedTouches:r}=e;return t&&t[0]||r&&r[0]}},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=r(50);var o=_interopRequireDefault(n);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}t.default=o.default},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});t.default=distance;
/**
       * Returns the distance between two points
       * @param  {Number} x1 The X position of the first point
       * @param  {Number} y1 The Y position of the first point
       * @param  {Number} x2 The X position of the second point
       * @param  {Number} y2 The Y position of the second point
       * @return {Number}
       */function distance(e,t,r,n){return Math.sqrt((r-e)**2+(n-t)**2)}},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=r(52);var o=_interopRequireDefault(n);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}t.default=o.default},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});t.default=requestNextAnimationFrame;function requestNextAnimationFrame(e){return requestAnimationFrame((()=>{requestAnimationFrame(e)}))}},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=r(54);var o=_interopRequireDefault(n);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}t.default=o.default},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});t.default=closest;const n=Element.prototype.matches||Element.prototype.webkitMatchesSelector||Element.prototype.mozMatchesSelector||Element.prototype.msMatchesSelector;
/**
       * Get the closest parent element of a given element that matches the given
       * selector string or matching function
       *
       * @param {Element} element The child element to find a parent of
       * @param {String|Function} selector The string or function to use to match
       *     the parent element
       * @return {Element|null}
       */function closest(e,t){if(!e)return null;const r=t;const o=t;const i=t;const s=t;const a=Boolean("string"===typeof t);const l=Boolean("function"===typeof t);const u=Boolean(t instanceof NodeList||t instanceof Array);const c=Boolean(t instanceof HTMLElement);function conditionFn(e){return e?a?n.call(e,r):u?[...i].includes(e):c?s===e:l?o(e):null:e}let d=e;do{d=d.correspondingUseElement||d.correspondingElement||d;if(conditionFn(d))return d;d=d.parentNode}while(d&&d!==document.body&&d!==document);return null}},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=r(56);var o=_interopRequireDefault(n);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}t.default=o.default},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});t.defaultOptions=t.scroll=t.onDragStop=t.onDragMove=t.onDragStart=void 0;var n=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e};var o=r(0);var i=_interopRequireDefault(o);var s=r(2);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const a=t.onDragStart=Symbol("onDragStart");const l=t.onDragMove=Symbol("onDragMove");const u=t.onDragStop=Symbol("onDragStop");const c=t.scroll=Symbol("scroll");
/**
       * Scrollable default options
       * @property {Object} defaultOptions
       * @property {Number} defaultOptions.speed
       * @property {Number} defaultOptions.sensitivity
       * @property {HTMLElement[]} defaultOptions.scrollableElements
       * @type {Object}
       */const d=t.defaultOptions={speed:6,sensitivity:50,scrollableElements:[]};class Scrollable extends i.default{
/**
         * Scrollable constructor.
         * @constructs Scrollable
         * @param {Draggable} draggable - Draggable instance
         */
constructor(e){super(e);
/**
           * Scrollable options
           * @property {Object} options
           * @property {Number} options.speed
           * @property {Number} options.sensitivity
           * @property {HTMLElement[]} options.scrollableElements
           * @type {Object}
           */this.options=n({},d,this.getOptions());
/**
           * Keeps current mouse position
           * @property {Object} currentMousePosition
           * @property {Number} currentMousePosition.clientX
           * @property {Number} currentMousePosition.clientY
           * @type {Object|null}
           */this.currentMousePosition=null;
/**
           * Scroll animation frame
           * @property scrollAnimationFrame
           * @type {Number|null}
           */this.scrollAnimationFrame=null;
/**
           * Closest scrollable element
           * @property scrollableElement
           * @type {HTMLElement|null}
           */this.scrollableElement=null;
/**
           * Animation frame looking for the closest scrollable element
           * @property findScrollableElementFrame
           * @type {Number|null}
           */this.findScrollableElementFrame=null;this[a]=this[a].bind(this);this[l]=this[l].bind(this);this[u]=this[u].bind(this);this[c]=this[c].bind(this)}attach(){this.draggable.on("drag:start",this[a]).on("drag:move",this[l]).on("drag:stop",this[u])}detach(){this.draggable.off("drag:start",this[a]).off("drag:move",this[l]).off("drag:stop",this[u])}getOptions(){return this.draggable.options.scrollable||{}}
/**
         * Returns closest scrollable elements by element
         * @param {HTMLElement} target
         * @return {HTMLElement}
         */getScrollableElement(e){return this.hasDefinedScrollableElements()?(0,s.closest)(e,this.options.scrollableElements)||document.documentElement:closestScrollableElement(e)}
/**
         * Returns true if at least one scrollable element have been defined via options
         * @param {HTMLElement} target
         * @return {Boolean}
         */hasDefinedScrollableElements(){return Boolean(0!==this.options.scrollableElements.length)}
/**
         * Drag start handler. Finds closest scrollable parent in separate frame
         * @param {DragStartEvent} dragEvent
         * @private
         */[a](e){this.findScrollableElementFrame=requestAnimationFrame((()=>{this.scrollableElement=this.getScrollableElement(e.source)}))}
/**
         * Drag move handler. Remembers mouse position and initiates scrolling
         * @param {DragMoveEvent} dragEvent
         * @private
         */[l](e){this.findScrollableElementFrame=requestAnimationFrame((()=>{this.scrollableElement=this.getScrollableElement(e.sensorEvent.target)}));if(!this.scrollableElement)return;const t=e.sensorEvent;const r={x:0,y:0};if("ontouchstart"in window){r.y=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0;r.x=window.pageXOffset||document.documentElement.scrollLeft||document.body.scrollLeft||0}this.currentMousePosition={clientX:t.clientX-r.x,clientY:t.clientY-r.y};this.scrollAnimationFrame=requestAnimationFrame(this[c])}[u](){cancelAnimationFrame(this.scrollAnimationFrame);cancelAnimationFrame(this.findScrollableElementFrame);this.scrollableElement=null;this.scrollAnimationFrame=null;this.findScrollableElementFrame=null;this.currentMousePosition=null}[c](){if(!this.scrollableElement||!this.currentMousePosition)return;cancelAnimationFrame(this.scrollAnimationFrame);const{speed:e,sensitivity:t}=this.options;const r=this.scrollableElement.getBoundingClientRect();const n=r.bottom>window.innerHeight;const o=r.top<0;const i=o||n;const s=getDocumentScrollingElement();const a=this.scrollableElement;const l=this.currentMousePosition.clientX;const u=this.currentMousePosition.clientY;if(a===document.body||a===document.documentElement||i){const{innerHeight:r,innerWidth:n}=window;u<t?s.scrollTop-=e:r-u<t&&(s.scrollTop+=e);l<t?s.scrollLeft-=e:n-l<t&&(s.scrollLeft+=e)}else{const{offsetHeight:n,offsetWidth:o}=a;r.top+n-u<t?a.scrollTop+=e:u-r.top<t&&(a.scrollTop-=e);r.left+o-l<t?a.scrollLeft+=e:l-r.left<t&&(a.scrollLeft-=e)}this.scrollAnimationFrame=requestAnimationFrame(this[c])}}t.default=Scrollable;
/**
       * Returns true if the passed element has overflow
       * @param {HTMLElement} element
       * @return {Boolean}
       * @private
       */function hasOverflow(e){const t=/(auto|scroll)/;const r=getComputedStyle(e,null);const n=r.getPropertyValue("overflow")+r.getPropertyValue("overflow-y")+r.getPropertyValue("overflow-x");return t.test(n)}
/**
       * Returns true if the passed element is statically positioned
       * @param {HTMLElement} element
       * @return {Boolean}
       * @private
       */function isStaticallyPositioned(e){const t=getComputedStyle(e).getPropertyValue("position");return"static"===t}
/**
       * Finds closest scrollable element
       * @param {HTMLElement} element
       * @return {HTMLElement}
       * @private
       */function closestScrollableElement(e){if(!e)return getDocumentScrollingElement();const t=getComputedStyle(e).getPropertyValue("position");const r="absolute"===t;const n=(0,s.closest)(e,(e=>(!r||!isStaticallyPositioned(e))&&hasOverflow(e)));return"fixed"!==t&&n?n:getDocumentScrollingElement()}function getDocumentScrollingElement(){return document.scrollingElement||document.documentElement}},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});t.defaultOptions=void 0;var n=r(58);var o=_interopRequireDefault(n);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}t.default=o.default;t.defaultOptions=n.defaultOptions},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});t.MirrorDestroyEvent=t.MirrorMoveEvent=t.MirrorAttachedEvent=t.MirrorCreatedEvent=t.MirrorCreateEvent=t.MirrorEvent=void 0;var n=r(1);var o=_interopRequireDefault(n);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}class MirrorEvent extends o.default{
/**
         * Draggables source element
         * @property source
         * @type {HTMLElement}
         * @readonly
         */
get source(){return this.data.source}
/**
         * Draggables original source element
         * @property originalSource
         * @type {HTMLElement}
         * @readonly
         */get originalSource(){return this.data.originalSource}
/**
         * Draggables source container element
         * @property sourceContainer
         * @type {HTMLElement}
         * @readonly
         */get sourceContainer(){return this.data.sourceContainer}
/**
         * Sensor event
         * @property sensorEvent
         * @type {SensorEvent}
         * @readonly
         */get sensorEvent(){return this.data.sensorEvent}
/**
         * Drag event
         * @property dragEvent
         * @type {DragEvent}
         * @readonly
         */get dragEvent(){return this.data.dragEvent}
/**
         * Original event that triggered sensor event
         * @property originalEvent
         * @type {Event}
         * @readonly
         */get originalEvent(){return this.sensorEvent?this.sensorEvent.originalEvent:null}}t.MirrorEvent=MirrorEvent;class MirrorCreateEvent extends MirrorEvent{}t.MirrorCreateEvent=MirrorCreateEvent;MirrorCreateEvent.type="mirror:create";class MirrorCreatedEvent extends MirrorEvent{
/**
         * Draggables mirror element
         * @property mirror
         * @type {HTMLElement}
         * @readonly
         */
get mirror(){return this.data.mirror}}t.MirrorCreatedEvent=MirrorCreatedEvent;MirrorCreatedEvent.type="mirror:created";class MirrorAttachedEvent extends MirrorEvent{
/**
         * Draggables mirror element
         * @property mirror
         * @type {HTMLElement}
         * @readonly
         */
get mirror(){return this.data.mirror}}t.MirrorAttachedEvent=MirrorAttachedEvent;MirrorAttachedEvent.type="mirror:attached";class MirrorMoveEvent extends MirrorEvent{
/**
         * Draggables mirror element
         * @property mirror
         * @type {HTMLElement}
         * @readonly
         */
get mirror(){return this.data.mirror}
/**
         * Sensor has exceeded mirror's threshold on x axis
         * @type {Boolean}
         * @readonly
         */get passedThreshX(){return this.data.passedThreshX}
/**
         * Sensor has exceeded mirror's threshold on y axis
         * @type {Boolean}
         * @readonly
         */get passedThreshY(){return this.data.passedThreshY}}t.MirrorMoveEvent=MirrorMoveEvent;MirrorMoveEvent.type="mirror:move";MirrorMoveEvent.cancelable=true;class MirrorDestroyEvent extends MirrorEvent{
/**
         * Draggables mirror element
         * @property mirror
         * @type {HTMLElement}
         * @readonly
         */
get mirror(){return this.data.mirror}}t.MirrorDestroyEvent=MirrorDestroyEvent;MirrorDestroyEvent.type="mirror:destroy";MirrorDestroyEvent.cancelable=true},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=r(60);Object.keys(n).forEach((function(e){"default"!==e&&"__esModule"!==e&&Object.defineProperty(t,e,{enumerable:true,get:function(){return n[e]}})}))},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});t.defaultOptions=t.getAppendableContainer=t.onScroll=t.onMirrorMove=t.onMirrorCreated=t.onDragStop=t.onDragMove=t.onDragStart=void 0;var n=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e};var o=r(0);var i=_interopRequireDefault(o);var s=r(61);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}function _objectWithoutProperties(e,t){var r={};for(var n in e)t.indexOf(n)>=0||Object.prototype.hasOwnProperty.call(e,n)&&(r[n]=e[n]);return r}const a=t.onDragStart=Symbol("onDragStart");const l=t.onDragMove=Symbol("onDragMove");const u=t.onDragStop=Symbol("onDragStop");const c=t.onMirrorCreated=Symbol("onMirrorCreated");const d=t.onMirrorMove=Symbol("onMirrorMove");const h=t.onScroll=Symbol("onScroll");const p=t.getAppendableContainer=Symbol("getAppendableContainer");
/**
       * Mirror default options
       * @property {Object} defaultOptions
       * @property {Boolean} defaultOptions.constrainDimensions
       * @property {Boolean} defaultOptions.xAxis
       * @property {Boolean} defaultOptions.yAxis
       * @property {null} defaultOptions.cursorOffsetX
       * @property {null} defaultOptions.cursorOffsetY
       * @type {Object}
       */const g=t.defaultOptions={constrainDimensions:false,xAxis:true,yAxis:true,cursorOffsetX:null,cursorOffsetY:null,thresholdX:null,thresholdY:null};class Mirror extends i.default{
/**
         * Mirror constructor.
         * @constructs Mirror
         * @param {Draggable} draggable - Draggable instance
         */
constructor(e){super(e);
/**
           * Mirror options
           * @property {Object} options
           * @property {Boolean} options.constrainDimensions
           * @property {Boolean} options.xAxis
           * @property {Boolean} options.yAxis
           * @property {Number|null} options.cursorOffsetX
           * @property {Number|null} options.cursorOffsetY
           * @property {String|HTMLElement|Function} options.appendTo
           * @type {Object}
           */this.options=n({},g,this.getOptions());this.scrollOffset={x:0,y:0};this.initialScrollOffset={x:window.scrollX,y:window.scrollY};this[a]=this[a].bind(this);this[l]=this[l].bind(this);this[u]=this[u].bind(this);this[c]=this[c].bind(this);this[d]=this[d].bind(this);this[h]=this[h].bind(this)}attach(){this.draggable.on("drag:start",this[a]).on("drag:move",this[l]).on("drag:stop",this[u]).on("mirror:created",this[c]).on("mirror:move",this[d])}detach(){this.draggable.off("drag:start",this[a]).off("drag:move",this[l]).off("drag:stop",this[u]).off("mirror:created",this[c]).off("mirror:move",this[d])}getOptions(){return this.draggable.options.mirror||{}}[a](e){if(e.canceled())return;"ontouchstart"in window&&document.addEventListener("scroll",this[h],true);this.initialScrollOffset={x:window.scrollX,y:window.scrollY};const{source:t,originalSource:r,sourceContainer:n,sensorEvent:o}=e;this.lastMirrorMovedClient={x:o.clientX,y:o.clientY};const i=new s.MirrorCreateEvent({source:t,originalSource:r,sourceContainer:n,sensorEvent:o,dragEvent:e});this.draggable.trigger(i);if(isNativeDragEvent(o)||i.canceled())return;const a=this[p](t)||n;this.mirror=t.cloneNode(true);const l=new s.MirrorCreatedEvent({source:t,originalSource:r,sourceContainer:n,sensorEvent:o,dragEvent:e,mirror:this.mirror});const u=new s.MirrorAttachedEvent({source:t,originalSource:r,sourceContainer:n,sensorEvent:o,dragEvent:e,mirror:this.mirror});this.draggable.trigger(l);a.appendChild(this.mirror);this.draggable.trigger(u)}[l](e){if(!this.mirror||e.canceled())return;const{source:t,originalSource:r,sourceContainer:n,sensorEvent:o}=e;let i=true;let a=true;if(this.options.thresholdX||this.options.thresholdY){const{x:e,y:t}=this.lastMirrorMovedClient;Math.abs(e-o.clientX)<this.options.thresholdX?i=false:this.lastMirrorMovedClient.x=o.clientX;Math.abs(t-o.clientY)<this.options.thresholdY?a=false:this.lastMirrorMovedClient.y=o.clientY;if(!i&&!a)return}const l=new s.MirrorMoveEvent({source:t,originalSource:r,sourceContainer:n,sensorEvent:o,dragEvent:e,mirror:this.mirror,passedThreshX:i,passedThreshY:a});this.draggable.trigger(l)}[u](e){"ontouchstart"in window&&document.removeEventListener("scroll",this[h],true);this.initialScrollOffset={x:0,y:0};this.scrollOffset={x:0,y:0};if(!this.mirror)return;const{source:t,sourceContainer:r,sensorEvent:n}=e;const o=new s.MirrorDestroyEvent({source:t,mirror:this.mirror,sourceContainer:r,sensorEvent:n,dragEvent:e});this.draggable.trigger(o);o.canceled()||this.mirror.parentNode.removeChild(this.mirror)}[h](){this.scrollOffset={x:window.scrollX-this.initialScrollOffset.x,y:window.scrollY-this.initialScrollOffset.y}}
/**
         * Mirror created handler
         * @param {MirrorCreatedEvent} mirrorEvent
         * @return {Promise}
         * @private
         */[c]({mirror:e,source:t,sensorEvent:r}){const o=this.draggable.getClassNamesFor("mirror");const setState=e=>{let{mirrorOffset:t,initialX:r,initialY:o}=e,i=_objectWithoutProperties(e,["mirrorOffset","initialX","initialY"]);this.mirrorOffset=t;this.initialX=r;this.initialY=o;this.lastMovedX=r;this.lastMovedY=o;return n({mirrorOffset:t,initialX:r,initialY:o},i)};e.style.display="none";const i={mirror:e,source:t,sensorEvent:r,mirrorClasses:o,scrollOffset:this.scrollOffset,options:this.options,passedThreshX:true,passedThreshY:true};return Promise.resolve(i).then(computeMirrorDimensions).then(calculateMirrorOffset).then(resetMirror).then(addMirrorClasses).then(positionMirror({initial:true})).then(removeMirrorID).then(setState)}
/**
         * Mirror move handler
         * @param {MirrorMoveEvent} mirrorEvent
         * @return {Promise|null}
         * @private
         */[d](e){if(e.canceled())return null;const setState=e=>{let{lastMovedX:t,lastMovedY:r}=e,o=_objectWithoutProperties(e,["lastMovedX","lastMovedY"]);this.lastMovedX=t;this.lastMovedY=r;return n({lastMovedX:t,lastMovedY:r},o)};const t={mirror:e.mirror,sensorEvent:e.sensorEvent,mirrorOffset:this.mirrorOffset,options:this.options,initialX:this.initialX,initialY:this.initialY,scrollOffset:this.scrollOffset,passedThreshX:e.passedThreshX,passedThreshY:e.passedThreshY,lastMovedX:this.lastMovedX,lastMovedY:this.lastMovedY};return Promise.resolve(t).then(positionMirror({raf:true})).then(setState)}
/**
         * Returns appendable container for mirror based on the appendTo option
         * @private
         * @param {Object} options
         * @param {HTMLElement} options.source - Current source
         * @return {HTMLElement}
         */[p](e){const t=this.options.appendTo;return"string"===typeof t?document.querySelector(t):t instanceof HTMLElement?t:"function"===typeof t?t(e):e.parentNode}}t.default=Mirror;
/**
       * Computes mirror dimensions based on the source element
       * Adds sourceRect to state
       * @param {Object} state
       * @param {HTMLElement} state.source
       * @return {Promise}
       * @private
       */function computeMirrorDimensions(e){let{source:t}=e,r=_objectWithoutProperties(e,["source"]);return withPromise((e=>{const o=t.getBoundingClientRect();e(n({source:t,sourceRect:o},r))}))}
/**
       * Calculates mirror offset
       * Adds mirrorOffset to state
       * @param {Object} state
       * @param {SensorEvent} state.sensorEvent
       * @param {DOMRect} state.sourceRect
       * @return {Promise}
       * @private
       */function calculateMirrorOffset(e){let{sensorEvent:t,sourceRect:r,options:o}=e,i=_objectWithoutProperties(e,["sensorEvent","sourceRect","options"]);return withPromise((e=>{const s=null===o.cursorOffsetY?t.clientY-r.top:o.cursorOffsetY;const a=null===o.cursorOffsetX?t.clientX-r.left:o.cursorOffsetX;const l={top:s,left:a};e(n({sensorEvent:t,sourceRect:r,mirrorOffset:l,options:o},i))}))}
/**
       * Applys mirror styles
       * @param {Object} state
       * @param {HTMLElement} state.mirror
       * @param {HTMLElement} state.source
       * @param {Object} state.options
       * @return {Promise}
       * @private
       */function resetMirror(e){let{mirror:t,source:r,options:o}=e,i=_objectWithoutProperties(e,["mirror","source","options"]);return withPromise((e=>{let s;let a;if(o.constrainDimensions){const e=getComputedStyle(r);s=e.getPropertyValue("height");a=e.getPropertyValue("width")}t.style.display=null;t.style.position="fixed";t.style.pointerEvents="none";t.style.top=0;t.style.left=0;t.style.margin=0;if(o.constrainDimensions){t.style.height=s;t.style.width=a}e(n({mirror:t,source:r,options:o},i))}))}
/**
       * Applys mirror class on mirror element
       * @param {Object} state
       * @param {HTMLElement} state.mirror
       * @param {String[]} state.mirrorClasses
       * @return {Promise}
       * @private
       */function addMirrorClasses(e){let{mirror:t,mirrorClasses:r}=e,o=_objectWithoutProperties(e,["mirror","mirrorClasses"]);return withPromise((e=>{t.classList.add(...r);e(n({mirror:t,mirrorClasses:r},o))}))}
/**
       * Removes source ID from cloned mirror element
       * @param {Object} state
       * @param {HTMLElement} state.mirror
       * @return {Promise}
       * @private
       */function removeMirrorID(e){let{mirror:t}=e,r=_objectWithoutProperties(e,["mirror"]);return withPromise((e=>{t.removeAttribute("id");delete t.id;e(n({mirror:t},r))}))}
/**
       * Positions mirror with translate3d
       * @param {Object} state
       * @param {HTMLElement} state.mirror
       * @param {SensorEvent} state.sensorEvent
       * @param {Object} state.mirrorOffset
       * @param {Number} state.initialY
       * @param {Number} state.initialX
       * @param {Object} state.options
       * @return {Promise}
       * @private
       */function positionMirror({withFrame:e=false,initial:t=false}={}){return r=>{let{mirror:o,sensorEvent:i,mirrorOffset:s,initialY:a,initialX:l,scrollOffset:u,options:c,passedThreshX:d,passedThreshY:h,lastMovedX:p,lastMovedY:g}=r,f=_objectWithoutProperties(r,["mirror","sensorEvent","mirrorOffset","initialY","initialX","scrollOffset","options","passedThreshX","passedThreshY","lastMovedX","lastMovedY"]);return withPromise((e=>{const r=n({mirror:o,sensorEvent:i,mirrorOffset:s,options:c},f);if(s){const e=d?Math.round((i.clientX-s.left-u.x)/(c.thresholdX||1))*(c.thresholdX||1):Math.round(p);const n=h?Math.round((i.clientY-s.top-u.y)/(c.thresholdY||1))*(c.thresholdY||1):Math.round(g);c.xAxis&&c.yAxis||t?o.style.transform=`translate3d(${e}px, ${n}px, 0)`:c.xAxis&&!c.yAxis?o.style.transform=`translate3d(${e}px, ${a}px, 0)`:c.yAxis&&!c.xAxis&&(o.style.transform=`translate3d(${l}px, ${n}px, 0)`);if(t){r.initialX=e;r.initialY=n}r.lastMovedX=e;r.lastMovedY=n}e(r)}),{frame:e})}}
/**
       * Wraps functions in promise with potential animation frame option
       * @param {Function} callback
       * @param {Object} options
       * @param {Boolean} options.raf
       * @return {Promise}
       * @private
       */function withPromise(e,{raf:t=false}={}){return new Promise(((r,n)=>{t?requestAnimationFrame((()=>{e(r,n)})):e(r,n)}))}
/**
       * Returns true if the sensor event was triggered by a native browser drag event
       * @param {SensorEvent} sensorEvent
       */function isNativeDragEvent(e){return/^drag/.test(e.originalEvent.type)}},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});t.defaultOptions=void 0;var n=r(62);var o=_interopRequireDefault(n);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}t.default=o.default;t.defaultOptions=n.defaultOptions},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e};var o=r(0);var i=_interopRequireDefault(o);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const s=Symbol("onInitialize");const a=Symbol("onDestroy");
/**
       * Focusable default options
       * @property {Object} defaultOptions
       * @type {Object}
       */const l={};class Focusable extends i.default{
/**
         * Focusable constructor.
         * @constructs Focusable
         * @param {Draggable} draggable - Draggable instance
         */
constructor(e){super(e);
/**
           * Focusable options
           * @property {Object} options
           * @type {Object}
           */this.options=n({},l,this.getOptions());this[s]=this[s].bind(this);this[a]=this[a].bind(this)}attach(){this.draggable.on("draggable:initialize",this[s]).on("draggable:destroy",this[a])}detach(){this.draggable.off("draggable:initialize",this[s]).off("draggable:destroy",this[a]);this[a]()}getOptions(){return this.draggable.options.focusable||{}}getElements(){return[...this.draggable.containers,...this.draggable.getDraggableElements()]}[s](){requestAnimationFrame((()=>{this.getElements().forEach((e=>decorateElement(e)))}))}[a](){requestAnimationFrame((()=>{this.getElements().forEach((e=>stripElement(e)))}))}}t.default=Focusable;const u=[];
/**
       * Decorates element with tabindex attributes
       * @param {HTMLElement} element
       * @return {Object}
       * @private
       */function decorateElement(e){const t=Boolean(!e.getAttribute("tabindex")&&-1===e.tabIndex);if(t){u.push(e);e.tabIndex=0}}
/**
       * Removes elements tabindex attributes
       * @param {HTMLElement} element
       * @private
       */function stripElement(e){const t=u.indexOf(e);if(-1!==t){e.tabIndex=-1;u.splice(t,1)}}},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=r(64);var o=_interopRequireDefault(n);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}t.default=o.default},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});class AbstractPlugin{
/**
         * AbstractPlugin constructor.
         * @constructs AbstractPlugin
         * @param {Draggable} draggable - Draggable instance
         */
constructor(e){
/**
           * Draggable instance
           * @property draggable
           * @type {Draggable}
           */
this.draggable=e}attach(){throw new Error("Not Implemented")}detach(){throw new Error("Not Implemented")}}t.default=AbstractPlugin},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});t.defaultOptions=void 0;var n=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e};var o=r(0);var i=_interopRequireDefault(o);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const s=Symbol("onInitialize");const a=Symbol("onDestroy");const l=Symbol("announceEvent");const u=Symbol("announceMessage");const c="aria-relevant";const d="aria-atomic";const h="aria-live";const p="role";
/**
       * Announcement default options
       * @property {Object} defaultOptions
       * @property {Number} defaultOptions.expire
       * @type {Object}
       */const g=t.defaultOptions={expire:7e3};class Announcement extends i.default{
/**
         * Announcement constructor.
         * @constructs Announcement
         * @param {Draggable} draggable - Draggable instance
         */
constructor(e){super(e);
/**
           * Plugin options
           * @property options
           * @type {Object}
           */this.options=n({},g,this.getOptions());
/**
           * Original draggable trigger method. Hack until we have onAll or on('all')
           * @property originalTriggerMethod
           * @type {Function}
           */this.originalTriggerMethod=this.draggable.trigger;this[s]=this[s].bind(this);this[a]=this[a].bind(this)}attach(){this.draggable.on("draggable:initialize",this[s])}detach(){this.draggable.off("draggable:destroy",this[a])}getOptions(){return this.draggable.options.announcements||{}}
/**
         * Announces event
         * @private
         * @param {AbstractEvent} event
         */[l](e){const t=this.options[e.type];t&&"string"===typeof t&&this[u](t);t&&"function"===typeof t&&this[u](t(e))}
/**
         * Announces message to screen reader
         * @private
         * @param {String} message
         */[u](e){announce(e,{expire:this.options.expire})}[s](){this.draggable.trigger=e=>{try{this[l](e)}finally{this.originalTriggerMethod.call(this.draggable,e)}}}[a](){this.draggable.trigger=this.originalTriggerMethod}}t.default=Announcement;const f=createRegion();
/**
       * Announces message via live region
       * @param {String} message
       * @param {Object} options
       * @param {Number} options.expire
       */function announce(e,{expire:t}){const r=document.createElement("div");r.textContent=e;f.appendChild(r);return setTimeout((()=>{f.removeChild(r)}),t)}function createRegion(){const e=document.createElement("div");e.setAttribute("id","draggable-live-region");e.setAttribute(c,"additions");e.setAttribute(d,"true");e.setAttribute(h,"assertive");e.setAttribute(p,"log");e.style.position="fixed";e.style.width="1px";e.style.height="1px";e.style.top="-1px";e.style.overflow="hidden";return e}document.addEventListener("DOMContentLoaded",(()=>{document.body.appendChild(f)}))},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});t.defaultOptions=void 0;var n=r(67);var o=_interopRequireDefault(n);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}t.default=o.default;t.defaultOptions=n.defaultOptions},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});t.DraggableDestroyEvent=t.DraggableInitializedEvent=t.DraggableEvent=void 0;var n=r(1);var o=_interopRequireDefault(n);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}class DraggableEvent extends o.default{
/**
         * Draggable instance
         * @property draggable
         * @type {Draggable}
         * @readonly
         */
get draggable(){return this.data.draggable}}t.DraggableEvent=DraggableEvent;DraggableEvent.type="draggable";class DraggableInitializedEvent extends DraggableEvent{}t.DraggableInitializedEvent=DraggableInitializedEvent;DraggableInitializedEvent.type="draggable:initialize";class DraggableDestroyEvent extends DraggableEvent{}t.DraggableDestroyEvent=DraggableDestroyEvent;DraggableDestroyEvent.type="draggable:destroy"},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});var n=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e};const o=Symbol("canceled");class AbstractEvent{
/**
         * AbstractEvent constructor.
         * @constructs AbstractEvent
         * @param {object} data - Event data
         */
/**
         * Event type
         * @static
         * @abstract
         * @property type
         * @type {String}
         */
constructor(e){this[o]=false;this.data=e}
/**
         * Event cancelable
         * @static
         * @abstract
         * @property cancelable
         * @type {Boolean}
         */get type(){return this.constructor.type}get cancelable(){return this.constructor.cancelable}cancel(){this[o]=true}canceled(){return Boolean(this[o])}
/**
         * Returns new event instance with existing event data.
         * This method allows for overriding of event data.
         * @param {Object} data
         * @return {AbstractEvent}
         */clone(e){return new this.constructor(n({},this.data,e))}}t.default=AbstractEvent;AbstractEvent.type="event";AbstractEvent.cancelable=false},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});t.DragStoppedEvent=t.DragStopEvent=t.DragPressureEvent=t.DragOutContainerEvent=t.DragOverContainerEvent=t.DragOutEvent=t.DragOverEvent=t.DragMoveEvent=t.DragStartEvent=t.DragEvent=void 0;var n=r(1);var o=_interopRequireDefault(n);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}class DragEvent extends o.default{
/**
         * Draggables source element
         * @property source
         * @type {HTMLElement}
         * @readonly
         */
get source(){return this.data.source}
/**
         * Draggables original source element
         * @property originalSource
         * @type {HTMLElement}
         * @readonly
         */get originalSource(){return this.data.originalSource}
/**
         * Draggables mirror element
         * @property mirror
         * @type {HTMLElement}
         * @readonly
         */get mirror(){return this.data.mirror}
/**
         * Draggables source container element
         * @property sourceContainer
         * @type {HTMLElement}
         * @readonly
         */get sourceContainer(){return this.data.sourceContainer}
/**
         * Sensor event
         * @property sensorEvent
         * @type {SensorEvent}
         * @readonly
         */get sensorEvent(){return this.data.sensorEvent}
/**
         * Original event that triggered sensor event
         * @property originalEvent
         * @type {Event}
         * @readonly
         */get originalEvent(){return this.sensorEvent?this.sensorEvent.originalEvent:null}}t.DragEvent=DragEvent;DragEvent.type="drag";class DragStartEvent extends DragEvent{}t.DragStartEvent=DragStartEvent;DragStartEvent.type="drag:start";DragStartEvent.cancelable=true;class DragMoveEvent extends DragEvent{}t.DragMoveEvent=DragMoveEvent;DragMoveEvent.type="drag:move";class DragOverEvent extends DragEvent{
/**
         * Draggable container you are over
         * @property overContainer
         * @type {HTMLElement}
         * @readonly
         */
get overContainer(){return this.data.overContainer}
/**
         * Draggable element you are over
         * @property over
         * @type {HTMLElement}
         * @readonly
         */get over(){return this.data.over}}t.DragOverEvent=DragOverEvent;DragOverEvent.type="drag:over";DragOverEvent.cancelable=true;class DragOutEvent extends DragEvent{
/**
         * Draggable container you are over
         * @property overContainer
         * @type {HTMLElement}
         * @readonly
         */
get overContainer(){return this.data.overContainer}
/**
         * Draggable element you left
         * @property over
         * @type {HTMLElement}
         * @readonly
         */get over(){return this.data.over}}t.DragOutEvent=DragOutEvent;DragOutEvent.type="drag:out";class DragOverContainerEvent extends DragEvent{
/**
         * Draggable container you are over
         * @property overContainer
         * @type {HTMLElement}
         * @readonly
         */
get overContainer(){return this.data.overContainer}}t.DragOverContainerEvent=DragOverContainerEvent;DragOverContainerEvent.type="drag:over:container";class DragOutContainerEvent extends DragEvent{
/**
         * Draggable container you left
         * @property overContainer
         * @type {HTMLElement}
         * @readonly
         */
get overContainer(){return this.data.overContainer}}t.DragOutContainerEvent=DragOutContainerEvent;DragOutContainerEvent.type="drag:out:container";class DragPressureEvent extends DragEvent{
/**
         * Pressure applied on draggable element
         * @property pressure
         * @type {Number}
         * @readonly
         */
get pressure(){return this.data.pressure}}t.DragPressureEvent=DragPressureEvent;DragPressureEvent.type="drag:pressure";class DragStopEvent extends DragEvent{}t.DragStopEvent=DragStopEvent;DragStopEvent.type="drag:stop";class DragStoppedEvent extends DragEvent{}t.DragStoppedEvent=DragStoppedEvent;DragStoppedEvent.type="drag:stopped"},function(e,t,r){Object.defineProperty(t,"__esModule",{value:true});t.Plugins=t.Sensors=t.Sortable=t.Swappable=t.Droppable=t.Draggable=t.BasePlugin=t.BaseEvent=void 0;var n=r(5);Object.defineProperty(t,"Draggable",{enumerable:true,get:function(){return _interopRequireDefault(n).default}});var o=r(36);Object.defineProperty(t,"Droppable",{enumerable:true,get:function(){return _interopRequireDefault(o).default}});var i=r(33);Object.defineProperty(t,"Swappable",{enumerable:true,get:function(){return _interopRequireDefault(i).default}});var s=r(30);Object.defineProperty(t,"Sortable",{enumerable:true,get:function(){return _interopRequireDefault(s).default}});var a=r(1);var l=_interopRequireDefault(a);var u=r(0);var c=_interopRequireDefault(u);var d=r(6);var h=_interopRequireWildcard(d);var p=r(27);var g=_interopRequireWildcard(p);function _interopRequireWildcard(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);t.default=e;return t}function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}t.BaseEvent=l.default;t.BasePlugin=c.default;t.Sensors=h;t.Plugins=g}])}));var t=e;const r=e.Draggable,n=e.__esModule,o=e.closest,i=e.requestNextAnimationFrame,s=e.distance,a=e.touchCoords,l=e.Sensor,u=e.MouseSensor,c=e.TouchSensor,d=e.DragSensor,h=e.ForceTouchSensor,p=e.Announcement,g=e.defaultAnnouncementOptions,f=e.Focusable,v=e.Mirror,b=e.defaultMirrorOptions,m=e.Scrollable,E=e.defaultScrollableOptions,S=e.defaultOptions,_=e.SnapOutEvent,D=e.SnapInEvent,y=e.SnapEvent,O=e.CollidableOutEvent,M=e.CollidableInEvent,C=e.CollidableEvent,w=e.Collidable,P=e.ResizeMirror,x=e.defaultResizeMirrorOptions,j=e.Snappable,q=e.SwapAnimation,R=e.defaultSwapAnimationOptions,L=e.SortAnimation,F=e.defaultSortAnimationOptions,A=e.SortableStopEvent,X=e.SortableSortedEvent,Y=e.SortableSortEvent,T=e.SortableStartEvent,N=e.SortableEvent,z=e.SwappableStopEvent,I=e.SwappableSwappedEvent,k=e.SwappableSwapEvent,$=e.SwappableStartEvent,B=e.SwappableEvent,W=e.DroppableStopEvent,H=e.DroppableReturnedEvent,U=e.DroppableDroppedEvent,V=e.DroppableStartEvent,G=e.DroppableEvent,K=e.DragPressureSensorEvent,Z=e.DragStopSensorEvent,J=e.DragMoveSensorEvent,Q=e.DragStartSensorEvent,ee=e.SensorEvent,te=e.scroll,re=e.onDragStop,ne=e.onDragMove,oe=e.onDragStart,ie=e.MirrorDestroyEvent,se=e.MirrorMoveEvent,ae=e.MirrorAttachedEvent,le=e.MirrorCreatedEvent,ue=e.MirrorCreateEvent,ce=e.MirrorEvent,de=e.getAppendableContainer,he=e.onScroll,pe=e.onMirrorMove,ge=e.onMirrorCreated,fe=e.DraggableDestroyEvent,ve=e.DraggableInitializedEvent,be=e.DraggableEvent,me=e.DragStoppedEvent,Ee=e.DragStopEvent,Se=e.DragPressureEvent,_e=e.DragOutContainerEvent,De=e.DragOverContainerEvent,ye=e.DragOutEvent,Oe=e.DragOverEvent,Me=e.DragMoveEvent,Ce=e.DragStartEvent,we=e.DragEvent,Pe=e.Plugins,xe=e.Sensors,je=e.Sortable,qe=e.Swappable,Re=e.Droppable,Le=e.BasePlugin,Fe=e.BaseEvent;export default t;export{p as Announcement,Fe as BaseEvent,Le as BasePlugin,w as Collidable,C as CollidableEvent,M as CollidableInEvent,O as CollidableOutEvent,we as DragEvent,Me as DragMoveEvent,J as DragMoveSensorEvent,_e as DragOutContainerEvent,ye as DragOutEvent,De as DragOverContainerEvent,Oe as DragOverEvent,Se as DragPressureEvent,K as DragPressureSensorEvent,d as DragSensor,Ce as DragStartEvent,Q as DragStartSensorEvent,Ee as DragStopEvent,Z as DragStopSensorEvent,me as DragStoppedEvent,r as Draggable,fe as DraggableDestroyEvent,be as DraggableEvent,ve as DraggableInitializedEvent,Re as Droppable,U as DroppableDroppedEvent,G as DroppableEvent,H as DroppableReturnedEvent,V as DroppableStartEvent,W as DroppableStopEvent,f as Focusable,h as ForceTouchSensor,v as Mirror,ae as MirrorAttachedEvent,ue as MirrorCreateEvent,le as MirrorCreatedEvent,ie as MirrorDestroyEvent,ce as MirrorEvent,se as MirrorMoveEvent,u as MouseSensor,Pe as Plugins,P as ResizeMirror,m as Scrollable,l as Sensor,ee as SensorEvent,xe as Sensors,y as SnapEvent,D as SnapInEvent,_ as SnapOutEvent,j as Snappable,L as SortAnimation,je as Sortable,N as SortableEvent,Y as SortableSortEvent,X as SortableSortedEvent,T as SortableStartEvent,A as SortableStopEvent,q as SwapAnimation,qe as Swappable,B as SwappableEvent,$ as SwappableStartEvent,z as SwappableStopEvent,k as SwappableSwapEvent,I as SwappableSwappedEvent,c as TouchSensor,n as __esModule,o as closest,g as defaultAnnouncementOptions,b as defaultMirrorOptions,S as defaultOptions,x as defaultResizeMirrorOptions,E as defaultScrollableOptions,F as defaultSortAnimationOptions,R as defaultSwapAnimationOptions,s as distance,de as getAppendableContainer,ne as onDragMove,oe as onDragStart,re as onDragStop,ge as onMirrorCreated,pe as onMirrorMove,he as onScroll,i as requestNextAnimationFrame,te as scroll,a as touchCoords};

